<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"09b92894ac102835b0b65cc89913e7b1e84a5e3ea2769e38627d9446689ce1b8d10d872e4cff00f38635bb89a6369983fd3637ee00ac3ce69bca8f8a04429ae30c44488b4b8e9f67df770d1681d8c784fc132d4511daec671003d0ad68e513df82018f4f9fcce2a5b8aa72dff4a239cb66afa8e490f5e7e0c86918b0baa11ad5e313d8acf91f1eb1aca7f726cd3cc45e7b62d53b0fab8c9fb1b6cded36ef75bd5023c4255d568f282d5418892884c8ca42fb757c9396b092d165fdff81b9b6812beb888c24c16baf2b0af605c0cced37eb1719c5be48fe36f40529464a5d9d2f6676a4f15fa643b24e803b962c58a9ca35ee6918855dba8c4ddf7246841dd3d2975aef262face12661bbe1f7c63a85d6ddf397c1f4502a1c826333a2cf1cc1bf14a54cc5c68d178959a3925626165379867be15c718c5518981daccfae5111b52b6b8c6a0ade4a6eda533d1f5575bef4d5f42925caa28fd809c655431902322762dd3bcc6a59ed8478a823864950ace6f61f1d426894ccc9784558d0891dc4975e3f782e9a549e883280feec5f41073f64e9c18f95dae07eee6d6adf4344cb62fe1b99b7931b285061c42e557fe94579bb690d27a543550a0959e6562e2c9472711ac72c0b83aacd12060a153df87fcd327e44d565401334041390ee80ce19b8cea22b3a8de288f9c1549921cdf6ad3e46863fc7d77153d43c58164dff68edc6ed9f226180476c4098d292ebe29a00f186d7c8581d34612632bbf05a33e9755763156f68c92b3b5cdc42c193bc31c98da964849ad697c419c861ec6b309f45e402f2dee410330a5d01e1869c5f6ea82677fca2fd5f0601a6246262df70654d2054a22218fe16728a36e9a33402de2f93db48675f0e22593ae929ee370534fb9cbf62f6cd423529b0c0fa2ef6c78cb8525f0ccf76fa2a97fd174e44fe7ad09200bb373892e766a336d0d923fcbbc96aebd053fa3fc761fc9caa5a54d04ac9790043c27c5a682c8d9002699ddd592abe70b311c884d6f8d297de5522e795242f739bb6b19c59b811b91bd52f64ef34953764ed3555d37312fe90a5a11413b07bb7b5adf34c07c5eb5fa12ae0c7188ed629cb989b125f46ae2b2136e90659420f6c295f0b9b8ed44d552bb2135907e24842f18c78c3b0f0af8c4649c1ad1522b0c66c7c578f480d221d2e9a1acfe66fc20d7c3ef01597b5d585e7c1617a8ff57df639767143ddfcdb2634fe20437ca793f9c6e361f882b230137aec973cd6954bb5cc49e718a69c490c11f7b73d036c8d4f55319ab2114466195724bc399655d45ebe2db00b7c30cc2a6ba16fd5e19f079cda8a7a92fdeb20e9a9bea06824c0fbca3c38bd0361c32638bc669e3fa52faefd9cb1cef5cd7a15f3a969e6fc970be939c4fedcf0a1942512165ecdc9276e124656b1ad581ffa4e781114fde8c1ee837810472d19bf99f3afb3c689d5dfc52ea247b4e3c4d11f5dc65d24816aa302c0da1d73f96f7bf95df880023576d4d89a10be32015eeb419bcd4eaacf1a3a1731c196e8e6d950f243c69d3c461f159a4a3e9c45eb973c1449a4fdc86b945c0ca3c3abc82575931fb5999ff24f2e424aa08dacf35e71ac2eb2101a2834867aaf98f6247b49f0b7cc21b8d4068eb2c216a03a444c55fd02c9b49af5c38048edb8a706ac547642644387f75e92b32da9e0616cc06e1e1d99f1f1a2a9436f0c8b1c4885cdbce8ae7059abd68202cb3d90ea4e7bfd3fb2651b1bfaad0e2462de0a951e5940c91487834dd324e6704f9be88c2bfee49742a1a91dc942ce098978a25146123b80f11b6b249cdb4e9419b2cc6cf74f2b7da4cbf752caf71b01cb1125c8389ba9957a207e20859f1ebe525a4404790983ea504b1d9f452ad65a4033f3999460714a290ae05b091f9d8ce049f85d663cdb9dff0dcb75c2063e55ebc4f183103c305c0685051f221dca6a5c45477353d74e4de8db8fe43786b067a3940152ec3f8be396aad753b771d96ebd2f946cdc00d05c7f873fd85a43348b94c6dc154244bcfe552dcba76ae22b6cd365d442646a5ca532e2cbd2259adee370795bcdaa2c0cf164dbfa17dcaf960a615afa662e4396cb59aede0f627bb00c15d40c27da92fc3727afbd1275f4fdde90a1d3788d7bb0aefba06c2ceacc393c320b00a25a865e2cac5731ec136aa25bf31658156a0d20f5d6c18e1d86860c568988ac202f3e44e69fe9fec03d0b1062cb4d88f35ca64d527c7a1c93ff5841f4139587b08d1b860f45ddb79a648816d1462521acc47189ddffc50508e2aaabe6197af9b82d12c471cb7865359c1f7535de214606477a06f3727f1005690371411c92e6417b20c16ba14eef7b9bb33f16e4cba282a3a412d2807c14843e9189213e9587d4b7c9dc75fd395313b217589b217b563b9c3c73afe3717048cc5da40b533e27d6ef069de071823093cdb2243a6f32529f9fec76f84a0892b96deb77ef83a889bc07ea085c081e35185859057e1839a75f5749cc7413953a969750d62314df0a2ae8fce9f5e5f6d16348c730723f3bfc7b6a8ec0fbf945ff899921c43b7eea11326f42b6f79de88074e6cd5c05f08beb9b65ffb1b098bbed1177b34b9201cb1083ed3a2fcbce8954ef31f9ffeb1ece360dfe866d4ebb1c49baec6fbe6c63d3a8934590abf3a06ea965069921339081cb513ceac42f811068357341406097534c18531bd74ee3049f1ab6ea868edd4d0950d208eccd672a0bab0093e2a0d2ec93b7d4e7f07fc6cd9830fb9b415c6793dddf33733565fe735d193011141bee4dca84fad79806cffc9ff2bdfeeb144cf3236a8380394771e11bc6dcd6c625328613862d914132b12a3e8f75574bb69f5f9310e54beacd37ed3c2a412be17691b4ce13a1baf445e0c37972283aacb724db8d690b64441998eba37cbb32fea88e432a0e600013cff4631aff63932d85ace56a1f3e94a61d39c9563bcd7d31902f4cb1e64a3f872cdf5844777de2cef32e7e63585a4d7a1cae9c4b193e5e4f1029aa2e82171915e8457a72fbd7b9dd0526fb331f3f0ebe16216e5aea3378c8280dcc951556df645fc3eda59a87508b71aa82ff3e9b6183180f6c8fe0783918c259ccf980e64b3d80d9641fc81c94c3ef083e28e293bb0eca14c17d12e46ab69d858c617eab8f91c8c6aea693ed5388840fb5ee42bd023791436b87b814e95ce35f681d7b93faf3716c17cba463fa6eb375c613f0a809ed735c1be73e398da210d88be14bd4b593880bda180f3f00a9cf3c31dd1b6671893437be54e1ad3cfec75bf23803c8a93d2fa7c85741aa2ff6b6c76e6ce6d1cc828835bd03ee1213a63208c543c3054cd2ef307611dc45558302a8c0b6855a6a5d5c08b17645a4b852e69a83336c58394c5e1bb77c37a9a9eff96883417d8d699ba31d8cae339583d04fdb3f78991be04a448450ab4905d9323fb4628bec9e937a8c3cb2858acb29beedd9af40e1859ba6e710ba1db2024109f052e81d3e5165cd97e4015206d2117c7ac9f526c901ed068abd57fd8327e43854f9a24206ac26175eda14cdba39fee423e56f552e8537004a65b55b3d270555b8b363404a76af8145e98f87e16c4706b2b05fb1d3c167335903e3866dde786b34e36cd6f746953b8e0847483369592b218335cdd7cde49ba6249881ebe8b84f1d22389a2a8bb61894fbe3d87df3cc155a9060bfb7f1943181b543cb3a734cb78a99fc19ecba0271dbb0606db01b07541628293461ebde3bf76ef9a595c6fa3cf2e7626de71eaae4c575b89f617776401636a6915a7a9c99e959b73e7c7646912a8685c346a2c41bf6b21c5933b59e0fd37a674bd0bd215b23f26e4652e07a418709fa3055103ad4ec1a5fce6cf381fa2e391c6c2fa208b8d171b7b645a3b842f01b6c13457df594e0068acc42694b835fbf5f005bc82ae6a1338263a1c1357c715d740bd09410295dc9b885ab7ec158e2f13422fdd94dcddb9eb8bc787701c0ca9d988b2b610f1454c1dec22e190d0398d620dde65e34c60a5a170a9f68c7a1f053da4f1108e6bd002b981269f0142a1fd52c721169379103457796b98c33077b6ca18bd9fb2e22fca886ee8efdb7ca59ba6de0d1f51716eb268e0068e4d15fc1e1ba7974faffba3d7fa08a34131231855fe3fd667757cc6c25600c8c40af0275b852861b77e79162be04eb9d142974b6d8d62eff51fff9a6f0074f69aebfee3276a47e4f5ad296d061103ec9f190dd94357ae05fa4565dfa42c020d642e82d651a510467cf691595ac1e447e63a911a73cdc22663625abc3071b7c5dc1fcc6f3bed10e4b1edf9d4c5d72e4fac66abed41e28573b510e84711a2344eb811c8944f159c706287848b7fd5a8d98d7a000a2bbe72cee5fe21d0170faa7dc4ddfee0ad07dbb582cea72f30f20ed145d975f95c0290326d14caf154e1b0723d157401da6c52c16bc1687409367613e0331d13e2bbbbe69b822f8196c0eced4cf58b33dcf26b61bef0b83b54ae4c3ee31d1694258a9d156bc51f08c5de641f9c8ae463e316294e780a016df91b4a246ac47f354cf3639106d966e246a73194c0dd336903865a70ecaa4c8080650e146db90b5aa271ad89bdd31ecff771ed8b88f9cb8284409ef728fc66c55299fc4aab4686c1e78adb489030e9ba09127cc8f9a4dc8e238c1299913af3730b2b06eab97376bbead25f936e1d0467d353e540d20660fbd2def36b6e638bc2db6204144c43e6209897dbf4f8ff26f4c6836270a64cf20c599293670c01477d1fd16307fd0c3bd41ef1d5f5adf7f76d869b73f9be56431e1e473ecc9c3e8adc7ef774e393a4c3d85b5d9aa7058a502c681314a84dd140a1f7024fa5f8a2426e87adb7a376107d67e1b6b11ef842f19a2f457fc060a96e8dfd401073c7f9910ceb2aeb7db07aa27b302467cb3584ee822a65617fe59139855fd045663450ed7d83ea26ad03c71a159fd325fc6da683eb6852b4dd0f780de539c6f719514807613f467c433da347e02945e6f76cfd57597e8a12bf743e89bd9d787e8f57178123223bcbe0771a222f2c60a0f06764f94cf7d114b0df7092a6599a52580d2195a33368a34cb96706c9d13903e84b35501f932ebc2417d17311f34461cd568e5d1b6e8aeb05d2c56ced5042916a61054fe803210941b7719bb8d784d6fa44c6ac079f296f6a76596f08861f6f9d8814495af0fc50070423dd317ab598db94ed132a2ecbd08028fec1f9916f0aa68435d343c3d31befaf0e45518422b16ac879b90e01321000418941a8578574f8ed949f6382743c2698d7f926f4f6220175ce32eea4fcf671804ae508d95fb6623b29ca3362e7e7093c5e4b0e15da7f302cdbc32523a962488dd23bc5373600cdd4edf1ed18cbb6ac0750129c3cd31c7d17a652c3ba582ecbc92cc6fcf2f6642a8fafa8ef73fb79bdb6f7c27068474f4b2e5b43ffc1ccf4a90f3f0da86ea9de2527e2f056975a41e0a8ff113420dc49f2df5821c0fc2300c80f36c9036d1d0710a843a82bb3f61de437d8ce1a7957315cef77041898328b2e4798f9a1b8ec9b924b52c8eff01e1d33ebfa06a4a38b359b112c08a2117d6d850e144bc833e827ec8a647e8d00604c4576f6042a1afd708c8c322da8315d664b51ce5ab7233aec5153f66cd0950d3c895db5a2f8be722b70a34e2ac3f19636a5d1bc5d51d3dde10fb6084fb65fffc88994d6072becf90e3ecbe27400e56d4a584d97fcb8884231afc447c91100ed17655fc6c3f268fe9fdb461b60a774ecbeb7a662c90ba70a0cd9943603c7397fd7ac7758e2a61a28213398aba0f3383fece6b6a4692d3d2e5135339b7dd7461942339b121a284f8c6c842b4dfdb92042de575e6b7b40dd7f4ac9f181d311a8c1bf0b26cba784d31b45f501a4434833d1a12e28e6223b31af49a942c3314a46ac53ec85c19350ab592b2e4282d3aa7ea87031a6923fdb2a4370adae634eff8dcf1849ae55347f593f95f959751c4eca8d985b3dfabbdaf044eb7704f49fa675a1e8d78841ba2110823df8d5cba5bae95915c59dfd82be851e5ccac0ca3411a21ae76398b48006520a27f05002355b4951b31e41a15ca45a544194a3ec9dc623cab7fd42fc9bdcb483027fb6aa1af029cb02dd46b677b6103f6585d5df5607bb6d4c65310e5429f84c9479f9a1d7490143593b3e226328f336e2f58e3ebb8a596351c829d836b93a893235056cc4b31f0bf83c7e04be647e42bf15039acb8588ead56628248a3e3cf8f7323d315a915f07fac784acfe41d5fabb0782cb7c854cc0c8ab6a9acebd6292180ef94b9a3bfbc8e9134fcce98192c62a0b7c86f03bf1cfe7f8c7fb9bd800d524e6d6629c1c42ff8c3cd2707c67178cf97d81dbec58d8bc0e289b50e93be279c5ddbd5c3dce3265d1e76d63c6357a66fe21169405ddf6ba523b0ecaa48b2045afbd81c7958675c76779ad384a34388a77d9b2d012bb2a9e214ad3116196f017d9766e50bb1eb0e0b8c44da9901d42ed26d7dbf0ca4ed815538126d28e0a6a977dff993b1b7684dc87ad699d2349aa0fdbd163126c88c14f0e7dae293d180a83ae9ff584ec1689cb3b2fb6ed7be5a041f1caaeb4616a989aa31ae08942ef12914ade61e4a5d733bc9a2db0642ebd1f11ec14f9c9ca2fabfbc42a8e47d0dbf034128c42b237f00c98eb71751674314b74c465aa13c3561fa5f900a1db19773e5022c462bba4094ae162cee4cc90d39f1a26111a4a2e0738147a07622cf6a3ee5ca0d1b8c1f52acd225aa97ccc420330ec5d05ab3986caa3b47b87e696cb9136e651c2652ffeb78675c78c9a010aca74f5ebc8afc67491c5d8907a809a0c8c5b5f7fd6f1c1844bec75500cf270543111b1706566e406e7aee00919a8b05b357aec5c34082a82c3db44e82a37e650e10d200973483251abce9b3415b51a9dada19f17aa9c1c976bca6b7980d1b56687ecdfa886a3c8bd937e5482f9af38459caf46749a9b1690f99d6344b25f9420d563e104198b3f69ea188c6c6dbf94c0ac6ce86a056a505946843e304c8d9b98034bbca5941d838bd1a60bd6034b9e1c7307decfc4bc30d554a1857097cdd1ae76b6d181accec8f688e0f9da8115f29c4e6dd58785de979b3d887ea54276ba4249e3a28ef39fe0bc1bd2a53ddf515b3059f0ed6ead3041f8cbc04df6a13d1c540b9c0809bbe407d67ec4ef77de49048e5a78508fc878c9c4e498b49157448bd57c520660ac8f1b36ea15fe0691ba071182b2ac243ef63d7a1f4da479445f93ac9666b54d6a7261f717d262ac0da459e73d2deb8863c9d6e9bdbdf511195e3a9708437c3d241b39d9f2526b8662d986a39fe1027d7d7f0cf37f071c0d8f0178c011ca9c2d57bdb1d92184fe233b837fcd759da605a3350d1d38a99e1d54dd35af918764abf5061c9143559c767b597c6cc0da462b91351861c6602d671a271c643e52fc0a5dd4be85a4ae0f83ee5948f4a42eaf717644539605d88f2543387f84d25ac921ba3d95a8ee9845ad092a1405582096e118cbbce4230304ff4a7a967eb4bc7c17de2972a95fdd6ab9074a2acf8891aa9190dcb25528e0b6a373503528a638c34ca3193fa87be3413c05b108287b870a219d621370bc5fcc457245430ef2735154346519697aa170f8dc47c18c063e98c260c9543b186c11c17604fc4f9509daea2a2ee6053132949fe0811e0584924e55aaeea73bf7853c0f6f599c62376098b557936f2a9597a97bd4f0e6609d539e33bd64c52b93cd9a75175db456c0e2775f3c97d5c4dac14f4e9c39f8326daad68bfb4c324a50901d08bf06333bbd2d7684ce57466ae97e1e1e955760713ec3ceafb05359c91f7ce92962161b1b02970e96adf7edf7206e237f8065a15245d4e24cb482c96c7cab35ab45bf266f9516fe6317246c58d79a8ef984de59445bfb1fe3a05eb1710eaf07186e88254a1371187d772355e95ec501553ebf41ddba6c3026bcaf8f4827db4d903b2a59ab2873fce6d836c7ee9da6694f4c69cf07cab02266d73c659f3aab4e7a10d2b56b4df2bd6559c43435acd1a89974aa7aa839bdd8297e12254a6317869de8a2199b102488b960e320bc8090e63adbbaec7355d7aee8d06d233a78b8a744b9a84cb81dea411e439702bc8c0dffcf5d4c871d2be00e703198bf7e25604b3999f3917010b4ec63c2b9ec2bee9e86548ec6191ee558a471e9951737cee5cc5266886de9b54154725b2c3f13bd3f9f327044280794347c0e5251a2d130180b7513cd3f657160f2809292f8d06af181d9e45a34c63744d790b8b532699556557ae27f7b5960e1aa9e7261b570a57f2a71e76e7b139b8e5012bc30ac357462c6d1484c83ecca8d41631a3fa9924a166b6a5698317a2ad003cd84cf76aeac1a7e06580dbfdc50a77e5164a17ecc29221e9d8c9ae526b9de27075d69d2c2050bf0e514ee747cd26aca218c375368f176e29fff6098115555326884df2bf6f820390129714799c64bc45cf95010ec031117c705d13dc93769b16673309321b545bb06aded693dd4980f29ef444e009fb3cdf62b1fbae2a5f97ede8203fab88acc3d6ca6fa135ebc67057ece883fcd70426cc0d3e379b6fa425d21d205a2d5acbf8b92ca5c0b0a2cae3d6ae1522f97b49dbdb5d4dc2b07675615dd917b1cf319ed8d9499fef64f8048ac9276b8935bcbb8815fcf08f13c4f05d784a39db07b8a0cbf3844fd17f54ea6dd29663ac44eab26e4e85292a2f3ae3547e1c7004d4049740a26c68c0161235985f17f15998c4e8beb56136800d28ba608a0d3a5d50b409c6f5e8117a570bd334df88b119a21b6ac470fe447dfb2a55aff189768b1d6cd3297f90be25e9609f0ca8601bd36babaafb97d0d7f97f690c4f423d9b87f0e8f4dac4f8c9b5754cab7d7c73ebbdea413b235fb020a66ca122dc90a5de6a682a50b31916c974b34d65eaebe7934531fe581ba4b09a14fb7385d2ccd5bdbf6e3251d0f194d2d54dacc8ba187fb3b3a4ab6bbe666057919e803b18b0a8dcb3d68027dbde3cb1f946a165bf76ae94903d2dadd4bc04896b18d0a08e763dfdfef04584e67f25dd2916dd451db65c31f7931d7bf7be9b06235e5c7cc604080c910e1836a5413d2f6c591eab4ec662ceb279e45e7358c28a0e6bee19332580c6eacf9427e505e231e8e0749df94e815258aeaedf693f9c56bf32a90c950ab1f23bdce727e1fcfd989a1ac38b29ce5ba9ed6c9b8e67c42ba0f4b6087920969fe41bbd7090547890fdda71840fd8b5429d9c0fe71f7b713dd8650114f69c897860d0fce8caf0031273e7c92054adde0c6a9c7cc638ad9d4722d12a67acc90f4c81c48400f7768ab7e2ec1c4b02e1f0bbaf60af925b36927d40b7c278eb92bbf44744783bc302e9079cd3846d6ac5cb84fe60b3d8114ed847b4e2d6a52f4af529db5ecdcaff9f19c3f6f3d37a157c979843df65d3a643bc3bdf1b25304657837bcf64028fe0d83f6063d97fc6cca8e53911c3e720d18976e2c5c407a02a73a506e362e1cf5241e502cd242e625d7498feaba580134fab44f84d8da24a58fbe81b5953a53e98d91fc9b743ab2fee2e222c3bdddc91c8aafce0067e991b096561aa3e0a5163d117cfd3547270f82011c8645a56d325323886e8fe03e11ad469db6ebda20485c31e6efbeedfedf6c7def03239e27daba36c585c38bf4c82fbddbfa027ee92e1911207c0f59767b5476f376f8107afb19d4287067d35c375182cc4309408a122c7e69fed3d282d61391c9074f7458c0e406a5d26af7faae27a5fd94e4c971f1de39db3a38c2105e2b86ddbb635d479d36f66b08825ef64f0137090c86a3d451c9fa6b40203d60803d2654ec949690deeeab9ab35694aab7afd5d07d36810d7cc7d67e67eda3785771a565c7709b1e16ad590c549620c811cc495aa6ad1f1f5ee1652bc8f3bb4dc82e2e88a9d965b207e8b60dd520ba88d054861378651d97a820600f003ea6a24f4a6d47db28fc79f1e142f67adfc55f2dcb5b6ab9e59bdde22e8258d40b5f4abd19b84921aee62417203de1dfa8e567662cf6432acd44483d6054eaf77aee61e29c5fc7be6c8da2bc50191eb93cf01fce98797ba898d226a249e764959776db2ca9bcade168e5d2656f60d6fa625ca0c2395fd74964b6b96805a60deb4016345f6bec0c89daa35f779583b5d9a4741f0d93104e250da41e89f3aa0b1c32fec3b6f7b085f921cd6c338de18f8c76e7454c24633835b39f97e11d2b0c594f51f4c22c425c5c8265e2bfedca9c70c63d1a00547e791796cd1978bd32451589b554e152b81924cb4bfcc590207887a7b9ed3421d20f9a5515097405d400089db32f65ed1cff4b3a097b9fe5ca6d2a3b613c0f117671912501725009f16cd1259651ccc399abb597e8883d6cc74a3be04ed8bb73f108a2508882a31194359e25524e2046715b03f28ee478f7552a8bb5afc6edef9eda4e332790e685cb47ae972b05f0a1439a004ed3e188bf01e3b8ebfef06a6266da8d41a51f1bf94af2246f56b1263657163033c12fa59b01b76200a55afb0541e5249725fd098debd41a921d2a85e8bccc8416bf950b4a1b541b2aadfefa3248a3a265e830c28ef585ea54dee174d1112ea35feacbfa9e352be2f1e0304f1b5facdae3281241cc50ba540051f74eae2ab6884874083c004ccb7988a5c4b3223c65f9280f0ff1581382c4c58530d92592fe5e0b1dfebaf75cf39e31f5dd004f55febe11f904a954a9087dd2aa1349f95208fc99b6776d72e314212c8c3a85a1c2d080666a4910fe54bb44dd4fa0386cdc3a8a7c30b0c999b92353a0ad69d877ce78dbc45692ede9cf0255dbf223b82b746ca3332ab6d60662ed3e798436db95635116a3cd46d6667549ddc55f33f5397a1b0c08461a3cb566993c60d24d9a1dcd9d3ee7b167e0fd670e779e9f1e3c89596575ba311cb9761e29eced255661e852901d375474be723932b2ac6c90971896b2e0976858eebc166bf4e45434c180cddef80715c169b89593a826cd91773ce79df6bc0bbcca7f05c68e49064519ab3b08e771d8cfd60f728fd2fd033e1fd3ce80b5b7ce22f0e69c99039b4e4551b5339a92e807d689f8a28162556e09e4b9275ba95b4290f4a004080e7ad2beb4713723930df26f51c920ef605408d2131747d544a2228d2ab3471c17ec0171ad70f5391eb2ae2633269c982c983b4fcb731600b282d16a62e3874cd8c0607581322c9f7f1329234c9385fd3a55c8185b9506ff258d1880c02b54624c61d0a136f48ca1cec5414dfa34bb3678b77576bac617d06ef5181a2a3ef718c3c57b41452d306863d81341ce3dc4f3a88f41abc0f73453764e631a1f95b7c5e583241c40c739e9bfed1edb8db79d853d6d5835379c7cd3afd1df5aa5531bb4cab91669c38edd690c1b13f067fd5f9e23632f330392f9a4c284ee5747420bd82fbe1c8bb18a716c3bdf0449cb9fdaf1cfedf2b4222de5bfb848c38de888f81a09ddecf2f11a8e091860a0c152dc8c655a342a236a010867486abc568b9313efc9ea25b876a09664b20c1c7d931fab12d86c1a13b6368bc20b725294c974fac979a1ef4f38011b29e7dc6b31ca14e2417e24ecf96b6615541be166ee76eed3b5f2ab627035c26af46873bcfccc34fcc3915aaddb12fb89e194d3afa8d5eab5705cf7612267c338c81afe9c28ae0cd62d4e733ea62b1c1538b9cff3286a2327a3ebe13cbcaac8a30e0d45ea2eb231961f8d077c34d9e5d0387decf847500b00e278151520a38ce568a10eac3cc42bf88cd88b257a3f51e83263f6a90ddd6f1aeabd6ef611e994ea97c203b379ecf90f7b60ad9ba89cd0099a02ecf0d852cd168ace6b15d9144e27eb1cf9add7b336e06ee58e637a6223b69c05df2857ce8e95fbcbf20d3f7c388e6711611d202e6222db443400e7ed77da32f7bbd5d6208d989fbc8410cc49cf24a35e215be1a2136194504ab0763f42db82f1df7315d142968563fe382d073a09ae4df170807dceaa1c31d8661a9cb24dd0557bcde5d85a0e318992d7989bcba685d57df2e8e9b69f2ecde558d7745889c823d69e1f77d9cd036f5a83cc6e570b1d4bc604da62f2f4e4834d2021e408fa03af72ea97198643106bc783d28b8e6c897d0e69d4e823c88e4cf98829d57185e5116795fa6320b65a3548cdc2048e55c9f2ebb9370afd3e0c13b2c46eeb5a93172694c11c893625fce432cb3866678976efcdc77b2080ef9856f8b4a9687b415190096c9cbd325731216788ea96351734344f5bb0416f2b0a42885885fb520535e356c8954c3f100162a6fd696be44dffd9e167c6690e7e425b4597c392ad511ea69ef69c6acb11b022f56034a5901966f96d078ff0c03353c482b853ca00c672726d8e2755054de17fd3314b3ed88b86c0d1865c246143a6f9aaea0da1c718e09ab967f0dee808ef54c6109fd8bb581e94394146d38cb999f841c63cdf9156597e766e51051f8eab3e384298522be5d0d257084c0be6c060719afbe450412e5b86d6df6cae08b038defbb3db8023cba5b9ac08505eb74d77148820ff27d42ee69fcb56204b9503d53bc71817f4ed2081e48f08b40dbac8a053277309abe88c2de2e1bdf1872944f1f59d14824ee5048d4d63cff7d0d6df6c998c13b594d75405cb3b8a914e6fa21ca9a63d6e08704bfd3135ac9d3342549f6cf6168713d23ab80d115f21db014826f1cf1cb6b31eaab769eead89ec9a495d856958725c6bc68686f635d5a51fb37cec978f4527a300fe129ef49138ff43dfd6439a1ed12dd010511b29ac5568a0d0bb3bc8369e628dc30a6f66bf645a21a02690fdf05e75e28a0422179fcbd48c7e7a23d0460bb270f4da9703a2b221659834f9cdba151f96be62b96fd65e1621b0824c86c811bf3f2c70e3d6fccca41b3670e2b542a19a7130eacfd1a411caa5fc487b845215e5b213fc048b0f91c0508a57dc4b1a4dede376e1802e841ef79f4741c5567dc9f950161947b5aca95a4d583a4c7c62de1ece39a75df553867d891e89b72f5c0787439d05736d91e015756e35af1ab3b1706da9803b664665fd5ea0fb17bd00f8ef09ad50a72ec296d618abf2644503128076c65831954422e36d9dad8584b7ba730229aa62d9775e82212f8e5c98068e8a1862a18b9d4eb7abcfba24e667eb3a484c67bc2379b2b2321172d8df990ff7ab72955d52b9d910580d688fbd33972cee4eb5704c6fb540b69eca4bc763cc6e69d3e9622dbce2e30f09cc3e256a9c53ac7aabddc1e47aab5710501385bf72da2fe4f49c766eadd47ad9e35b817b6efe325650a5439dfab9134c3fe8d6a54a55444c3e220ebb15c1e791e5bc6bbed28d9df37930fa38a6a6e5c5b9fca77ec3836a5b76a87c21ac6b5798753a7deb28b515ab82a4ed84482ca62226ef9b59339958aa3e4fb4bc48118b9ae3d2e989d6ab48587a0e8530f2c6727d72b715a43813d4f7c7d6182994c9dc00816e3c284309245b6c6b38b3e076fa35858920797a96ce3108956a0e0268c8388e6581257dea65c3efc9a021a5390b9edf5f442d31707ccc7b04a9542285c54974dfcdf848104cdc073be262da55dea46d7cda5018b5fdd78b61b22b2692049a3fa971ff599f691c7e8a67f1cb6be29922e107cfa1b4f57395dc3a5e713632a7c85d18601d1e53e0cfe14dc55c9a39a66188a8993797daca37342030584b0ab3960403c6732cd94151b1f5ffb738d0f457f3334371e3f118ae25d4a07bd9da2ab89197425c192faf820cdc9230dd828effb5c6c22447e29b674681f6cb012b7e134081f72b6a3471f51ba9b445118906b7d15c335f6e796b5557add4a835b3f00c49d52f260d66b45fa71775e127852148b9655417467c6899cd3a3a7591797d4c9fc15273522967b8579971187004cabb68689baed017ab070c73389c3ad42d56846bc59d7632c3a37e92c44a336479667bb7e0c1cc23b6e393974d916df89b87d7f01fdef809c75daa70d2e0500fd1c335c3e8763136499f2be90476275e93dae5742e61d43e53bfbfa7bf210fcd754f97d75c7502d04d2a4949fbd42e7826d51dfe7b42d6873e71194593a148fa691fdde1fec4386ad9c87b9d7bd0ff0e4b89a1522ec25825722d0c7aed805941ba442bfa3148e7c2d932c5211638ae4a9c444fd5a059394bd3c923a8ea29e1d505d55c2c43286048131ad7535ff82f55efcb95ab35888a07c64733fb9a22e899ef4e1c91f82e252f05520cdaac7dc01f9f47e2354e99794130cf44e07c8987f2f85cdeac99997aa133e6e4fc1ef2557c837e88548ab430b9156c71c65c38c0300d2f207a7bfc82812b4ef5599c9fa9de04b7a49c7656e3bee2db0702f62cd32b238d7460677caaa0117b1fc82ac87d0bbc2ad634c996541a94c02c605de9bec6e39a417a88a7a119bfd42f5504571cff14f593a031eb852338b5a8aed55921d9d263883ccab3b98c1afd0aec07481e9f8b5dcfa43d6f1b0d959fdf60769b3a2b748cc26dc67579c8fba0f4695cdff3836d03bb422ef8337298eba4ca1bde3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"bdb79e3b0432a41bc4f5117424f3d0f8"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
