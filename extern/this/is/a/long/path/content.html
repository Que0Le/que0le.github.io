<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b0c2295546f9c1e4dda7783fd0c43afd9078302c2298ce9decfda3b493cddc0a90ed71c598bfa851ead61aef60bfbb64c234e8c69f1c8334ea045596815488c5fd52505794b71b625c36a6d445732e4c776a84c99c2bd0c0d88ad43bdf5ded0a916be81654338079d9780e820de0d1229be6191f358739ae128bef40aa70480f76ad9879d5b6369dcef56b25b1993ffdcacd8561550e898184375a575fae65e0197cbb6790faa36aa623e6809d296a0b57d14011e7a6a630b5899d1267adb1da4823f8d0fa523e7fc20b4592c95eb28e53cf8ad1dd9aeaa386f19f2e267fd21e8253709cab2e9e53246a2acfec659d087dd8657b3057c75bca99c562d46ab66309cced2642d2e3352397bbece432ede4472d47e3ca7001b551a33dedde60ed355c9912dbfe43dc3fd19ba2ea8f14dee0b501fc27fa584d348b772bf9211f0b7ab97ffd0da135d8df35254b66806a020cd1a697d7cd5990b9f2267383472bd76ab0ebb75e51b0938b4736b8c54ed00ceda8dc9fd4ed3c45b12f85f96a3dfc72865b16d0732b5b6befde61ec055318c3caa8ba4da81ae1d1771a6bbedb9d4ff37f2bb6b86b0e576e1aa3af8078231e8de07e33f5fb361b8cacaad579532cc7480e54fc11dd34b49e793c48a6f5c8231a7d1bb127117c292df73793d9f88906831c1fdd795c1414629eef7779799388d48c9f1fbc42137e45169f47e3fdd64fddcdd6935b3c386d25942b4329c1fd858caec8626d285af3b53c34275c248e5976af3b4bf1ae767b23db10fb0ac49ddead10c76210493928f0f2d527b23b8155dee446d3b4b05c793a215cd58a7ec7948e7627b5ff0924008082c2f1092818883b6a6133a905e2071c07e7b615b06cb745e8bd65e82ff0c5694c0a71b472256b384590dea09278bbacb6f6ffc162d5277e23e5372d4a0bd95a0316e9d14478d144475d3553694b52ca72c28787dd0f42c632c5ae3027979f7a8fa10fac12ff093180137d5ee845b0ff99827eb8005d22ecfe830b241c331ef34b0531f0f1b419f1b209be5266c8401fcd017a86e470bc69c74e4a72e9f6d6b1f25d6a56a9ada4d0f9f537b6e9c42832c49254610acdb6e7eb8f32bd8c6dcf6f7e4b6863cc3df0be0c808354252cd73100fecad7ef35f76faa840da3f23cf8ffb0694722fd5b4158b6994287702247dc5d2f1d27a45fd7b9243d9da687e77b6c6d4c7da27ae038b55d742815947c97ab8beadae890f201c07641ae3eb0abdcd09127b6d14c1a52877a0d818737aac909e14a857c4b20ebbc01c2e24729b7e6c1f1c0d5da25461c3985dfbd407443da2b8b614e1e65a72eb67e11f626c135110c9e70d3774025037d807f845d069a467a4a32eb486778af16515dd86b1a2a2480e96d41d9e5343a8b5acb2aa9f8e67a46932e19cb9a17febb1958ddd2910c786eced17f22b419b2912336c9889344e9570ef44646707517cce20bde61113f8c80f4fd14deecd2a4455d0c66acfbaa1015abb26664a001c13b8af4527f551199462c968e94fa17a04bf935dee1a6d22a55bf87b69c3cc3cfdf8326c206f7192807363dae05a67a0045b235ab0a1795b86798123172438f1ba64b2a4abbbbf90ca9588be8ff3f46f177fd219debc68577b6e220de43c066cd380b387ab578f0e67347de55e19b83cbdbcf74c68d89863da656971dca6f829ddf1336ae3b125750957fb1e743333c563844c0fbc2673c3de416889746178340270e9e3e6f3bb29b96e59916576a0fa5a7b358ce0c4ebfdcac6b1f32747bf6012e1641fb626c36166a049fe71556b6403737f28e8e8a640bda13282e67d6345c4842804953a99e3af728489ca9a1e8591b94f2d817fb353dc6c945592afcc365b614afa8ea8d726d005df04bb263308568ad6f8d1e0da728676f0fa5bfef7ba9450e1998fcfa3464b06c057fdd80d102187733a08960b68e319a9394dd0ca15920f0d803c8ccb39bc7ddd650f90e14accec1fab023bb1c879d12bad48a970ff4b1ce54642275a209a359a93a6e1c9b938bdfec906ba782f22ea5f6a0d4fc0ebd6b62c3b9b4242c78d2d46bfba2a5a3d69a7fe2cc2eb615e20e41815bfbdca4d91cda7b75165c260c2685fb9c3e5524a5820db81c5a405fc6bde0c6a25e7460a71be2b5f8f423f1008726094f2242dad3749b199a301ef07ff244317893cf141b5096c2b8128f5c15e72027b3eb4b40ff7821128a2d6f3449ea7d3d28cd768b8a3f9b2d956d9a4258712e2d8b3f04bd2f515dec9c5f6c05e841fa60d6beacf6bb52dd3baeae21a17335a4ec678b74cb3728c749768a0aef14c88c30c3ad4c6d25a6e97c74b9c97cf9fc248a016761cbf0d24bff530e3e399136986cdc97003b6b162352a234e1c5fb2b5744526acd13c869f7fd5997df84ed51e9ea6733bb6a8055e9a2ca9b3e75b9812f4ba00c6e387e57830fa3c27180c9f0a4a0e712ae0a23e65465e80c68b471c2dcaa2fe4404d5d5d02375646eef7baaf785f3b612dfba39ab3ba3dfb64a77fd1e731cfa19390bddb5af365128614fa2ae1518fbf0b5bf4e5132fee074097f80c1ec8394e7c41889b65892b47f76d023e430513d45ffaaa43fab7fb007985f39ea077f739e97120a3d7e18fb17014958257976b3b6459b929dd4e14c246d18e65fa2157bac25559e80924f36e1620d9a477783ef883e956454dbcb93e4641dfc9b6076e4068029d72e3de720fd991ce72066919ae9e1c4eff13945632caafdcd9ba8fc9be48381dc312f903b5f8e40cb35af2660abc1a0a271c40d59366f180222ebbd106b6e27e3f1411fb12062777cafc95e0c9d10eae46bb5a427ce17dcf30dfeab83fe264ca4c1f51b8f3943f27055cc7f0b77c7dc7721916cbbd6810561b37002dceee174af4518e1f5c68c20d3b13c2dec3b664100f897d3d0853ed5a335d3c6f0813169d21aa5ba13c27d97561571599640d52b360a1bd586f8469b522b39b425498c2a767607d4f8a891a0304cb1ad5e940730ad56a20a58afbd8dcd6e7940555c1ea502cab3d1898a959c8de19288784ca143c6237139ea37d4a03baad81e4f1d93fabeeb18db0f0e05aafa8aee8db4061196e12f7dff5d90086253abdc8aca65f200e4e058e69e43a4f7b93e976e590eb4049e4cba091d1879bec8d3ab994cd589f582269f450cd3387736284d3e81223aa8fd32d16c0d48d1002c9f7f7d5c05d6697c7a9c8c5d60bad734038599e92888eac27a637c1fe33f7182cfd1b4793291c6e835a973e9cb106b1815345fd06c4a88e62563d62dc872a6e69c57432024ea8cd741fd90ad29bf3020257cd9eb4fa240ae15f8e66a8e2b51e384f97538da55454e60557edbb8bc9de3028e1c94f99e1652b57f490a8c4bdb7ef57e33b65780face91d72522973ce14473b190f6131bfefc3d93a8da175680deaa2cdab99c659ac3c9ae25e203599da501f798a527d5e554be69f091bc6bd0facec781db49fbbaeda7ff01063248a4557e6d5d503549f5bb8a03c15b8fdda50bacbc7da548912b0d93983b08b60b83f26a9382c9bd8f291d684d8782f1e12af2fd4b53b36637ae3d3f434b6cb1cf53ebbe33df89ea52672f2ae24e54bc9eb6a4e68acd5615af693cea4bc0f7ced6574f0f159be3adb0f1f4eb11b86b6857b05638a6ad2460dc89611c90e22e6c88a43cd78df54c605a02dd506c5a1cc11ed8d0dbf6b00b80cb37b6839a1a2a11dc01023d68ea33d744da7498696ac5fb0ecc4dd3315057a2ec17e12e2a1fef653f5f27aeb975cb481c0b1290cec9880c74d4744830a00cc02002ef17491898ba8a7ac13a7dfa505a3c5402164e4048c264b7581b37f1cd8d94ae8d48fb3c63fa27344bbf55ecb323bc2db9af70c5f9e6b3492dc4283338cfd262d09b6b88fa7c5860ec10ada7b3624eae423ad551f55e3232de8fca85748fd2e7a20e5486f5b58fb5c7c71fe4366603a7a220e26f5aa88e681b9fb736a26691ba1aaefc517021941d1aec7c250c24a73a71e1f07138e6555812c8ca481d96063facab72dd29a3efa5b01cda0f38af63c2dae0fd089b1e5173590b66c5a5965ecdef80738e8e4f13247620932ba7952e89fce1d5340a995a4bbd204f30244d8cf5176608e7910524d9e3748254793b707768512ecbacc1b8db789ac9c4fe5427b5da2079f2a84beab266f667606593b8b9dd0c2e98751203e6909b27c63a086b10228dba8ae70962ec8ad33f61058dd51ac200b74e611304883937796d6c045b29e0054348205692c4f4710cd9a0274d6846471e14c598b34aab73040f7e237bcc8a2957d6eca15fee2d6dbdd8c7f416c1f58a5a5830dc492ba6fb8fefdd7ae3da97fbf8bd671520b18b427b6c8bf9db2a6f771470c2318d45bd4b2bb9191d6ccb96310b41f3180a8b3a5450d9d87159583f9a87d3faa1858c17e474d057652787069588327a62234d6ab249bb98d8647077a057d137ce70a24ce2be4adc1e03cb00de99cfb11f0985bae93de4ecbcc4b136dfafe71d1fd11b7a6e40d45caa70435a190b2a4d23a8a358b410868c9aa88b6334260620ebeb9e3ca9c66a980457ee75231ff3bea68d52ce7baab0bd3d8416828717605c05a8b2e8075200607c4242a486a868541f0f97f4885e3724722bbe4d1ebbec959cfcab186b7349643379d1573ed10e43adb8dc5c160fb81d33ac0ef75a3727d0a9e2eec10dcdd168cae49aaeb893c65e00356841e2629cd3c340f0438e358a924204884b7316bbdb2c98cd41a70cedebd7fdc32ba65f60d46d2db53cdafb4b39465a6a53dad3a43a1e0bdf8ef059ac696633c315baced6d65d7f51c8b416fafbc23a2f80857d8ccb0ea9e7348a92227c4d5ab86eebfe1f2194a095a3a90a8a3bde45fb081117432fc933b6bd432ff8b67b997e862341d454d4101ffa9128ecb05498e04e53a0e290ae460465da2236458682dc8bb86bf8590734aa40201ac53a7836ddd888a7e4bfd54cd1c8e69c39153b87acec16782b0fb7fe0835952ade755aaf12a166a96752bff04182c970b13ae4ad04b3ff2707317594f1254c108f04ae6a68208bae997dc9261ab81a63c16fed57d199276a9f46cf912f0c9aface32a663f5fe17406e40e27b187297989a7eff07cabda6a5973c9c1291b3ec0c9ff4ff8409d53449bfa5af1e3d391236761af13bd9222cfca58fbbc5ff49a45eba603c56feb8d57e0500c73a52a9d3ce35ebe294d3961a1ae1ffadc4bc8fd0fa2523cbd843f233decd46dc98827331c7ce79febbaa2c2a979bbfc7ed8402cfcaa7db6551aa3b7eef9363edff9921e015dce38a58278fad77fad056b1aa122ee4ae684f853384fceec6c77dfdb45413ef2d2253836aa3bf82fb377a4bae783f7f0289c86372dded5b08159e48102a01dfe42657ddaa1f3ea0cfa9b8edd4272809ca851ca51f1abc853da733fc510c116f16fba065e2c4c65f35b1e07fb24949f73b85699422067bce233d6f7f983d16526d0fc76a8c8837f23e71f1e48897d2b4c73758f2951cd7a8b3e9077ba656884539c56abe125cb5a69d452c1895e808e8647639bc202b3b66165572c36236a0af7befa9fa4899c3e6bd5fa034775cc6f254725b217c161b87632d440d42b49bf0407e51a81bbcc2e04aaef88d12b8f39e66ab8988318d7fe1d7366c940f79b5204c3cee21b130feb89f80270a1f10c1f2b0c169c1bb4a398f8fe4b75badec00e9078b58dc6d6891b966d76bc6e7dc974b3c4beea96baa90f416a50ee8a5ff5caccd601125dab4a314cb9b4caa3ebbdb5ecbb84e08396f114343c75e0332394c5b0b89cb7888b37218f2857e5627ef8b20fdcb07203b91c8a8f9980ab7842949a8a945c9be779020016cbd0de8bf4e47cd9b429829fb9f1808ce9a600e5fa38569e27f84fc77753bbc918f452ba283d17af29ca84c2b9dac0407152f2a01878a13aa71beea352ad321d803552def8e6aa139e30d35416de9663c7159e50b405e58ce31132c5f67936089184ad43693270b8d9237398afef9879b07c9adeebfbde2327a063a0b37e51671d57a9fa82a38bd39f5c67c0373f52adbef15ce944270eb0451d888204c0eb5547b76a3083d053e135ffda31f63b79fa5bb3c594391789d9efa7b84ed318416ead370a33a3ca6eb5bb87cfba12db4ab8df26877caa3ccd11d7b3e57ba7964ce0e1649d1668b226d979cf3370fd99b0d1c5598de6a5c745747696c6dcca4f1c548c64635d2c238f1bf5a3acdede4e547cade2383c47a6c00b4cde6ebb7cdb68c527e4dda4b046394c744dedb0ad4ddcdc00c91919cbba26eb353e82e83a500d27816249f0abd69a90e9cbdee16687141e0fb1c42ebeb7aba5127e27d089d02ee9f8e26ddd6ee2127fb56fc4dbd5212c2a32396f04a464e1240e7db321ae272c42d9aff6d523fcbf60dfa4799e9697e3df9c13583e58bf72766809306fc74a89616588e81c622543b45df73293c58f1bba62df7cdfc0bc3d7a0659a2547dc9ee64254fc69a85353b80ab20030d49b33be2b7cf6230a037475976079a639bf2379f1028db14cd314de0814ddd7b4cc40f8e21e2af410f069688f66f548306b63ea2f4784f019d32a90d1eb0647c5eb7349386303c9c1c3724fc11749d483de28dc4206fc63dbfd2cc3f999de465fae924dec0248d14fef5caae65d093548afaeaa4fd98b1891615b26279bbdedb9c626388a487119fc34ae1d0b1c23acca275b6d8ed2f578fc9c3e25534a4dbfe0599fc74863e1e54ad9ad9dee32b514c30b410e866a8d21841b3dac5a582bd2e217891df00138db4904991d7186805bc9e9c715d7951a4e80fe5b67ba57a3817522b8d61f1d1081dba5ff1432e39cc84b940833f86f182be9bc48f87e7398ab3f294f8c5efaf03752e240acc079be128cae243d9cebfbaf2a49b2971d79e890c75fabd733d70c8272e2ec9aade8693d8e9c8e4b12a166eb786c8aec6cd79dd294077bdb71c4005da3f91cba309c23fc094d8d66a880eada5edeaee4858117c65bf54a525ecbcead105e428dc9a57f66023101e6b68765697199665919412e1af272358310b8fa48d920effc43daf95663a783d2205673357eca1a655ab7370c5a3c3274cbbf5ac6889bf49160a941e6a7c5d0252454233b906a7904c5d803387179bbcea6f132249b444f8023975c64cf9cccf560cdda91120038a78f90a65054f95bd81dddb463efde4b9008ac805e98217a9a45b0d1cbe1956f8d93824b7b97560d7cfbe382f71a3c38422c90cc0151eb6c5cd7d52625e8d63182cbb6826512daed76dafc6bf8b83b366ddeaa49b7e498c36e642329f26f360508bbcf3928845a86f80f65b46025a689f248a3d3c3307dc0d7c3e15b18801a5d22364563bce8a849b5463bf8a8d69e2f583a4c696d415b3d4532cdb236d06908c2ff201c0508c6b5af95ef4e264b062006e44d066da3a05c55a34fbbe2c49a5d6df69e7928b7922609edf176bc1dc8f72a32507a075b06bfc65d993dceed4a97678b0400dcbfa223b58c10b5700a5e3b66b10f0da979e8f15802776180481df590a57cde8ab55a3a8881d14557b16da8d172dfc157cb4cd58b0dfb226269254f9c5ba7d0b433991da10ff11f45753477da6c1c6fe1a99e2a096315445315fa1d50f6e31875c09d670f6a3d9349cde0f75dc11f2af9c4ec2d938571c122243e2beabfd5a12ab96d7a36b0c13b1e1b71ef017a5aa9cc6c811b32ff8a09b1feb678eec5c93cde69629ad29c6f9848395d95d5b7bcf5b3c636c71588b3aab01db78c1f680cba1c0cb0da1a2ede19144be60dd78147c5e6d95bcebf65fab67c5c4ec3e3c5a5da839732c8dd0dd102c83fd47b7cf4f7d4202d109562d3f1564ff79813813fc05c1bc25ce8c260b03f16cbe3f412cf194262b0566a9dc0f39161628ad1bc670017d77ca21af3cca7721e0701e3848ed18253879ceae3407000742fa692c5209fe699a798669aeaed12cd09abe64e70006fe5339945e6dd2877eb4aaf6e97d620209ffc034f42d11320ce92d1017441804f6a85defe92e7d3abae117fe217ed39afc52642a4e7f807a4e95eacac91f844045fda09f9d378ee545a01a4ca6c6cbf9b3061876c16112786cb5dd9dc548246270df7f68cd50185cf1a6ab0bf1ecf76f71b6728d6d90f39f55ce5547ad2f0c954dff9e3935fd2f5f95027d94504596bbcdc7eef3fa805db66469ee794cadf1de9023adde65d9bafb16b1a6b862907b3e79dffae9b19e959eb0f32f5fb4e89de21aac8087acf0c32f98908b737dcbb65233e0483df67b224e0bb07f67455cee64e2253d1b6e9981f0c5dd55e6c87a1b7cb245c180f0985ded2406185ccd65a2089520ad618c03622b2bebab9d1d0c595eda614a5ee27a4909e67e5aa5347cfbec8527737005f3d3cfc88d72cbabd3166ac0ee171ed4312473763720d3131c7bdaf618d2d7974036987328e5eed505065002620baad46adee5c07415f455959118c064735c54421f388e2dd458ca51e44470332d5a4e998ad280f4a76fab490202c2dab0a1216de1771bef7663206cad470649c232f67923a1a7ac89b08d20b69fb98db651a4bddf1aed5409425e42365c724ca22179750d4eba7373b2b51b34d5d863c71035554cf208943f68ec3632ab9e37bc10a9a8e7077e0b6ad79df0a43f38c5f09529bd16afa0edf6c1a88126e5e33448cb7e7077dc0d7e69188","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"bdb79e3b0432a41bc4f5117424f3d0f8"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
