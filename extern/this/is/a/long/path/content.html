<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dfaf816e4047a224314b1d7af9fd7a38af10ca9993cd2a4f0d5e75c5f9c1de0c11dd87e4bba2a347f1e723c5f7b12327bd0f0326ebefac1ad87623543d587cc4c9cdd05cee30e0d06f8558b1c5bcce4e2b1bdbcb527f9fade54ba21955a77a26df373018164c4df3a5903543befbb67399afa7573afdc5983b851dec43d99def332743e816cc49aede24005783c7684665e4c43748015f9dd16251a8da2aae909c84573da80f5bba50e2a5117188aa2c239957618cb07e567a20c7de7c2b9c53c5e5f6c52cdc600cc7e807a4b30f9196b7769b94b3b8b60f26bdc8d1f83bec3d587dcd300dbbdfb573b6fe6d0acb0050948a791c882d80f4e3d86dda1574e59adf76ec08b6f13ffd1120536069cfc2b402a113fe81ae5e6e67b861e447f84f9dd8830eab1f35799fc2715c3b6c5cd330c2e1b191813d6023bd1d6bc7b4d1526c6f71a3617b411e28a67e0841baca7e8fee07edc91cb1cbf6f007aa6f6f4d42ed793a9fbe96976ef9f6ca72099cd3a60b47494ae13e9c86187711000f1792bd169b6cac7afc3fa529101fdda18976c70d08f884780b02fd5e4fc53cd4a492fcb7f57a2e5308e7908f08f959b3f1049f74d2fe8a05ab58daec5a0f7ebd03582b5d25927a076429caa334cdfa79ae3cd6335dadfeadc4c4bc533ca6b830ad90f96c4778c3ab88b4a6655c869f28df8a7b3c317e32961a2c872a6c7f1279dabe3d59487eaf6261abc18a301248fe129983f796c9bcd7ae36f759da38dea99dcf530a9907864da38ae61cca3011bb70706b6c026caf707e3858b38b489418ce5c6d9651ab41e626d33f07fd4ff8b1017b0213db7eee883d77ec567b44b368ae709ccf6be0b54d5aa69f88f7f9276456e639d4edcc80c59a651064b71d9fd7ad8a1eb5743600c6a96b825081e5038b08665894f5b1e7ce1c3b8f6390310e92726c42c54d81da911f2e804c6488a3cc999e38f5fd6b17379e749787deaa12a87e5fa4c8bb98c8a9a313736638bbf826bf24c7d3be1bb5573280efce0b01ce44eece6e1a1bc97dfd8800f2a7f4201704205d82b69a7b694dc6ed06876911bdd1a0a3a7f63942cb9d1317dc6ae2442e8b4137f501d46c52e4bb3414ef87585e7d3f4e6cf9baf28a51b14abd8c53beef10fd8e59ed14eea325a36ebceb4f843a8af4275362e3d737534f0878ed165288766e4575c6b1397c0b8c3508c8498facd29b8a2e493bbb406cc9866f693e5d85bdae8d877f87e8987d531ffd8e8d67975765e4d0553eb30189a5616ed22731b955098e3565903a935f2e2d3ea64d3d93d7e0d0b9b15ac728b0a5002aa202087e2add89872ca90d6722d663930cfe011bfb4e7e969b2e7778b167cfd11dd782f10239ed9d292f33ab27561c0ef4deb68165bab7fff3247c2905b087b2707893f8e95b313aeebf69d02c033ebb918f2e087c245355e9e7a92c2b79c0302501f9619a5971f4eb3ad13e6ad63c7e6dbb61a6eb86d6835205c7e34c57d21c3c396c3354a694cc91ac3454531861b0ebdf889025cf29a49a0a43e552c50137313bbc5deb193223ec413cfdeec46e38140f245506f1c7ae65921aaed5602c4e272f39919a0eaf77961aab479850cbbbad196ed2d33829727ea3b3b47c13692833d34c5423b8c62e7c21c5b1b0d8afead9250b75be1f594ded9193f2ac1528f8eab47e3efcc76753652e7e9da311737816d55540dbee77ec0b9d73d0e3b6c14bd685faeb29378cbad23b80527fffb5fd07a88d230438b687c622cc94920c6c99cf3d760f4f852f1454f0d3444b3bf9455317947c8e8e59c54b0a4dd173143b50c0626abedc142cfd51ce4e8731119fefeccf075332bde1e68eb4149c70648035bbe4f5b19788054f5de2b1b375f6044494cc9d7e029bed841f2c1e02a9283aa3ee47659c53bd5343815431addd295b490f14497db830c82135d3b126ad3a5e5fc424bbc942cb2f94ebbde7da6e2a095a2ec1bbdca25273bde8926741d88d632143b24f0e7376d04afadc96eb2ae013c00f6999087c06b49ebb82fa7dcafe34b691aece9becf4cd218b013afd0c693fc2edd11a26ae149d56faa6b60ecb7f4a50fda97b1064ab0980bf8bb50356546b2efa92a819f8f5b49271cecda464ed1e8aaeafeb44c9cf8ef0ef909a105c0f66878c0cc0373b8ba07042fecf8caada98cdb24c14c56c933e6e5ce1681a54e77b2d2c16abb107e1dc2c2eb7957284e8c519165bc9d2b4b0cadda6228ff0a9103e4f43a725caac7ee8f38ad2a82dca7f604eb7bfe9a062c665f7f0b767488fb6a320bb8ba817cc81ccd8a0389a40517b94e2242ffad5c0905cb1d8687f9dc467b07e9b120e4caf16c9539dafb04611c3d78c866194ca7a07f1b619be03bc9dd0a736151dec2d4f9815f593cb308d7b8786ea58478c850bda26425fae31bad35a5e0890c8c41ffbdb135cdae3b7d8ffae4e83bc7c7c73460f0a814611671df2399f3043d7d1e67974f36d5287b070d444f5a3100f50d087dec21f3347b6afef4d028484c8f3f799e521f5f538f807f1699adef3755888a7e6ff334691c89de5938b0e803a5eeff8e124a26c87431c8fb7a2f1652c0a2db024eb8cb2416cadc60d51d7c57369643739b726f2abc704471aaee853e97175aea1780481b13e39edc00bfe5530b1fe574af1dc243ea0f784ce0a301f06ab3ca60f689f17af173bea47ebb6b4924ea77a9ccbc7c725af3321c486051c50fe21f7ac2bfd6aa3dfa8eff6fba3f8c96b5e1e95681bcb3a646178f238911d3ede26a89a12335777e9896d0773ed895e0f15bf3f5ba7eb4f92419d99a349b185af0e2afe7b29440438e085a5f41cd6a86af270ac63d7718bf73e647455205ad513da2b21cff8dcc9f481c6f532d48d371365e7e709e851df1243b83effacc743cc82fd72196acecc1662f2b43a2014ff7443fafaf278a7c75f903b5abe8adb7727fc4acc498f79143c27d5a0ee7e0561b54c30c9b4c1b6976171a0742952bfeb7ab0ebe87137b4a18bb33c1906dc4ad91d19f9557b4d99672e68b067d20502a6253ed31680cf4aac7662e8c2eee7fe68ff47070fcd5b1cab902359cf81b86b7408da2f39ac823067003aa530652399455192b55560c9045b13633c0899ac791701892d64d8056042ba053760ae900e0e3561116a9a8f1eebc26bdde76a88f499b5c0bb62bcf9521bdea1138e8cdbbb9ff03434ab7440223afe76866275bfa5c304201f6b3eb1969adfbd840fd91b20605edf639073f120d3879c5831b5a6858b7faad3e9112c92a5dcf14712f1f56f51fe9d1cdc67c4cb8d8fb6266b6d8679cc3b7740447f7e3f7b5d404b8bdeaf77e54047ca1fd346da31bb8d4c89ca6accdf398e840c565db103c213ad0d03eb24664933b9e23a965b9f913bb0df24b01d3d718560d77f3b386db8627da4ef959486963b3b325abe5e3f350c1ce2e5c529afd59147f8a30260eadeca85e35f5af9a4b95c49a824658af8f8e530f1479d359a913ef3cba9df6e85bf1732f4feacff239c6e3139213b03853692a6d1ca53668133b1e019146652f338a9ab6d2813b9a1d2ab63ad5d7d1531e02c28a4cebfe540686d5e3a733af5b17c589a91a2b77e7afa76e7845e112ae9aed74cdc0e988004c374cc928032553bf7c14277bd527b85734dd7715c6f70f727b7b5520acf9ccbfb2c1b2ebbef06252f275f660d0a6ed57cc7f284af2e4177c27054b7738313f4f23ba094a7bb5d3ff779d4c19616089f42f47b2d03a6b1318b3cd23884cfe50e57e7260fd33fecf69830c1723ad0b110ef8e2b1951943f456c1d1906f860750d049957e1cd5545aed16a6b592166db722f6615a177ed6d6babcafec7b2e2d87416615db59b61794aca02dd6d98aa27f5b16c481cce9a411d119c4d0e98ba67cce9d4c7bb6c9ac1e544870f4f990d639980283c66fbcbe199dffa71a040e3eebb02cf314601106647a12fdd4b333bce8b0701f78a730860974ac9f3084adce0195024764dc12245e40d9ecc97fd5882ea5af12bdd2218e5652c41fb2fe36fdeb12526f223a3900b5615aecfbe47df7d1600ae8e6bc02be8c8554ab31a2e6d0de3764125b8fa3245a0161f8bc9005e3f24c4c3eb6682999c89efb7d5d55c9d7c3bd48472266debaba9c7fd9bd89776270b0eb627f3b93f6ad4bf00343c50fc9072d51e74315782d371e592c79edd1275a003e2f44115331c1669407ed17b5f51fcfb6cd97fddaefdbc0eb9d7545ed3151e2850bfeea915dc6e1d1c83287fc891784de5e51f6a1013720ff04ffe3766f4339746e58d0bc42bc1a1ef995b71d240b14c60e9740945d056472e03510291b5f70b7133008b92f92b6717c235b091737ae692fed94f3fe7fc839e6807e47ccb9860488b4cea5c04b3cfa6c935722d730d06fbcf0447a9404a75f5cf5506269d0b320b71d560dee544629d74cba5dd93055b8627c6513d0d7add3614c926db980c0edd83b05def3af5e409ca54c1c2f9a1c94eb165b0a32e421c24fb5699219a5c82f772cceef0caeda987f5e41882e2eb5e87dbd8e4a60dae8584d9f1d9e4a1814733c8ad4beef9de0f9594cb0fb1bc354a141f9165d6f753250e7683b9a7254822c1f02bfa0a1754e2ff16750cb2e11b71b4cdf78a8a14388e75cbed898bf63f9c6807bc0153a16a9673e9594894fdc66ca53982b7a5431d28806185d79988b833f134cc38f0128a13ad26adda9ef622a76c018162bffbcc75cf41224e847e752c6332923de112e081543a46ebc48caffa2054c6b3c77dbee719aea4728e7d2cd2d197da371bec8415bbb07d62729549aca7309164657e74796d37a6650609bf515403d52af9cdea9e41bbfe3d620d3fe292000b90d56ac27420ba3f95c0862c1ce509877947f64895e100e60487899c4fb0828df6fa877b3ddd189dd4e882117003b6362cb6380582ac50fcfdf2a9a3eb0150cf427cafecc53cb0cafa690ff4c50fa4883ce59f1f2daf4cfe50acfb615c022870e1bdf3a4e15a47ae612d2c684bce697646df11beb49918987b1159e4bd2029bd2a2ee1535761c54e94609dfcd61dcee450ed07cc4a3c4da39afbc905b62ff87660646a4925c4fad79fe51541aa4f70f50ff20cbec1811142410e668464177032eec0f9939aa195834cf0e5b2e781061ac94065bfb6f23038024e96abce90a194658a18256d9b47494ff8db2353100a9f20d9234bd1669dd0f782ee74426c071223d6c668c048b26c68f4ee60e74198945b5a5a66ee0d9cb46ec782cdf623124df0f608716bc2bc13463bfddd731c5a9c53f969e2ce9c51ef1f9dcd1fbf498326b3a46fdd596e2af9b3297b561394459271593f094af30d8d38e67af6825397880e899344be1d51896b837bad4da24a682ab62c672994ac8162a0ec24e9914a61a311587dd92cade864beb4b5c35bb07a20e5616dcf15c2266343d01d3f94eae21baaa85219019b97f069cc8994bf9a423dcd3f533db0e65ea09cee255951ec9cf06b3eb8764a7b6baf2891b8e085a14d65d489dc66c0ef7464f45a58f218285b04e75458a8f4b0b34d70b8537dcce3da48f1ef9a9de630e0e997d257895d7893470abeba7ffa6c87a5973058c09f32ab85459d6cfc2c10d97da23432d240426b3d9e459e7fa544ab8801f107d9b551266be117f14912a65437ba11713d3af12b6b70df2a75f30fa9f9d0abc9a09c3e6adf150d069d0e7c24d5e32a26dcee82fc4d78e4da9f4cc65ebfc05e1e78c8a4b2f8e58a9a512c503c9f1b1ebbfcec7bb828fd0dcbe4f4e098009e5edbb1bc76c06f00292584995911bfe4533c6b3683d596a593072edfd7ef7512bca2d4a94e235dd4829aca15d633c7fdd83ad2be97f0e11b33815402b4cf2ab75b7a90485069562f9b7095127e578d9ccb2e46c4ee14ddbfe5b5997696a66da7510ab61624e33101224f7c85e16d7154ad8787bf4a35e7b1c8de85a1c33667f79ae7fccd6478337be8143d61012972c856156697ba6a2b0c6c2ea1cb1e3461b39f9e226607b7f939631fc7bff9c9f773ee199210a9052d22df75a90865b68d4adcf49d5f74f3b22d98fd06390acf0c99a81305060a4e66a832284af8b7f8971c36f0c1f3e3602edafcda05df150b5d6ab74aae5b279d741de412311ec112aa9a1d02ad96109b6a137c9455261607d7859ff9bf2a3873e493b7954ce78609ddd10deaa4f336db43b90296fdcd623e91ce047d41174a4550513248c46f3464699164fdef2a73ed507794adafc241653712146bf9d95a12d77449d8ac72e9caeece099fe28b63de14e3607d9b9bd21fff2c5c67daa91ea4e8dfa9b4486ff28b88cd5e516f90f055fc671aec97cb1db825c997fb65d6504916a92c0cb0f9d697f4a2ffc7fa3e1b15f5f3d3825bd21978d618867bdc878df706432499f010907c6333274e791371a3220f0a93cb41c9a1ddc475a16d5f7b6ff4cec5d42037d93c3a460d02968fda3eed3b254b021f601cede2e09de2edf52e6a99c0b04427edd8cccd50de01998d0cdc736993e09418725df137ab13ddb5210f0d5fe062d472150bd0acafdce3716873c4101bec92ac37bc32a689281298d8352dbf0e0dc7db306abfec4f1084516553c480dfe077fff5a2f3480af6a0c34fa525382d7ee9048bd7a6bc8d618f5144eebb1625302def824c780490ed62da20364edc3b2600191317d3b2dd81f60e0dd364effdbfb7e20ac13b3fa65f12392d184b3a2c7c0d7839511a9cbf3c94d561bf8ffe7ab82eb19a0fb6c731e47e608da29732b4bb67e9c4e56f265eda6e51d674692a80381958bd244515ddec5084b18aa08f3e8990e916ddd627566efa599529229ae3c72b9dbc8029429c8098c8833cb28dd3166736fa0626cc43102ff4ef14bc4864b8518d785898a70073301b044d42d44d8bcde14b2854e4bbfd38351431bd33cfe793c9fdf836fe047c11e5ae91736e9e67199104d07bce97f9372a7fd0897f7a3f5b08decf4457ef29496cdfe02b63ca6b21edb7e03c6e540c48baffb4a22e0df16c337e4199e1bce679105e28ae4e0b37faab6fc673bbdf0fa248c664b899c81cb993613dbceb8164a0a98709b49f4b89e149a8135ee8575e30117055d4e91030a806ef8aecdce68549cd5873b9f17f03464d967bf94c6f1cb3c9ed58333022356798a6fbe30f71a1fd52ec54bd53923802ace387c3a43f3a2615df4629ed0d82ebc700a7f4ab9962a1442ac056668770cd3441eec8e28431acff1fdc7f7b508bc74d64df3242a2d3b57db21bd5eb8dc04f063772b5082f0b8c22298af36375164edcba84db704f61df3d4187e67d034358644e41b21fc709a0fc38bc384b8c918a3b8beed02ea652e113811362680040effa50e8160e69e88e7e80377ec2e407f6e97d771b3a23efd6e276ce6fbb920726efd89280698b7c93a5553e78dd41ea4f31c1e3e050e36540c9387a969d7edfb934589b47786abb6c8fb249ddcef599f919ca9ddfdfc1915cb49901bb6579b804815690dddaca587a131f6443a6d5dd09ffa7fbe2a74abd9ba4ffaabb18b4cb62ba6d3fd23361eda64c477a0064306812e251d3821d764f1644899aa1061563315eaf69c2e38e1451766f4a283b496ace082b57c4e80bdc8e1fcf19a9127fbf51d6a8b6cb6269d0161a6c6aa35aa8306e7954650c59a52a9c94ec21b7c3c6483c0b7eb498bec6d3528546d5992b9e0a0270fb823f79e65fca8b13ac439ebf792fd5eabacaf9bcc73be47a28c5f7ca6ce9802e033f7acc8ddfde0cb435090ca79244109a6799a242072f746ff86b33f663b5a852ee076b11eb504d4fb5679817c8ca2d75074ffad1db2bf3c05911bb5c53b5a86a6342767eaf29cd5ad308253663ed4b0c368e23e684c9c4c0a258d29d3e8070085398bf510f4d32561b96a630bec10debad540083cd1dfbf65aa37332b874fe35f3dacbff9c279dfef7ebb8553436631b51db7f8b361bbfb9a1016f78d213429166c6060c0e845b0d91a64784c3f86ed6de8b8b03d7efb30c904c05d6453021c1b8a10178ba2f210950aac17ae48b220ef0b16efc23adea42c00377804b41b0fbb05c48e52039398f662db9e783615fb956c93dc1d057309adc6333ead408d14106ef6227bd01fbbb8a54241842bf807a4ce065f400c041ec77512ba049a8108e9c48b876389d9f2f02198037709b857f46864197d6f32a49eb27f98fda83c1835914934cb441df3bac020b6e662cd053a9efcfb5937556fcd330fc6bf5c4af4543556a83dbcd8d02f2fe0065d898eb30eefd5478328c3fcfa70844a6b0a81d4fba30113d291749e22af062385487216d03f9435db4d72da651770d80fd63d02aab3fed69d00c9cb83f4ec64beec654c52503810661031955e51a812370ea1c9f60ba432654b76522cdca3fc5dc90a7580916ffe308f912d6c9e5d0067bfc299bbbb4d867e58fc41d862caabec7103b80cc15b46e97963252662390ebfc17bf60955a6e070fecf214c2f81c3d859fb16d87f37e55d3b93f42ea4802f1066e0119769a266540800614460a459b3c7fac6eb4f0338d264840312782fbe57ac2f8cc33f7c0a4033628f3f89c957db60bbfa13aac79a674e07e4c63fa3ea0ad64119def6c0166682df89c76e6295d953b0b6355a86a478811695e2e073fb71775cdb0b397440ab820145b10a2ad7dbe6ea3c7621bfbd838350c0ee969632df0067fe86308f0864efcef15f1cdcfb6ce57dbb545ae8d57df1affc8eb6ff967669698d793245b763c65a339ab5e7f81109111b4c31a579add51d21d6e5405e2eaca602ebdf8f78cda1e82dcecd6e6a2a5a36afb17edf39f33f90ed95d6e9e1373dbfb8eb18148a0d7f4b994bd4f76da3cfc29fe86b6bed650c88da5962a6981078092eb5b01f2d06cfabe71cd66ef8419a75a1dd1058ed578c66c747286595f1821b122e6233c8e2e0d67125e476ebc8b99161129d8f37aa4d8f6a06334cabc2cd1f332f927f5815b4b72f2f34ec63e0e927cd6c3f3b7d45fc22ac53c6d5d08f4d72071c569f1a6a7e653786ebe0ae07288d721ca02ed03377031f60b359abbb87112bce4c63efbe14d84163ca3d720ed5b246516dfeae4963afbe2a92ff7f7662936baa1600c8015a4402609606df72b78bd706e59ff333cf0ca97e763dde4c3ad78430673476ee357f9bdcb3ec1269e03333f99377b13f99ff135ece0f43c5df4de5b76bdcbc903149d672a25553f86f972ed530dcb8da4e86974e72b4603c16da317f55c9ed59994b5b580f83483c068c862662a30b371442e5bea3ae3cb742755eaa81a432ea85c43f5973a8b3e8ab7e4d2fe85add9352bd32012927cca30a374d56dbb131493a05b2d222a4057e74c15bd8a1946bb9d1491eb3525a052bf03384f945223093da5cf0b41cd70a053a22bfe191ea2165d25cd3580c571b24dc60d627fc5acf726239b2c9a2e9a2e0ef91ac513c54d3b3408da6fde9c630c17b4221e72ad025455088e80c0835c9ebeb76514b9d2ce3cd2a41e451cbce9f0e20856627631b649eb0fc10c8c5f936021fc55928177de04ea72cae4563fc48479dc42df9d8ee46ae78da76d1506e93cb87f4aea8c7d25b8381bed846eb3e3a04a3c2be20ea7cd082e0b5d429cb871510b5a082e8b31270d12709e3ad0243db7ea4857078762967a8452bdc29536caa218991ff84cfb1e132653f2744086cfcb71104aa27168799071c424203ea41361fd31e0b39bcfd1a1ae99fbfe9bdf1d877b0251fe9547ebec7bc13e6d095d457388ece3ec7345f2bfb6fefab8c66e3287f74221239d876aade1ea49b3b367df9604f8e8eea523a6b186e83e548d18ca06ee21d1ab10033b00ab31c4cf80ca3cccc35b85258004397b24907fe072518e9911cb91d00a745535ef8ad6738eddf1c255d511c81371665024c8a4ed3be4ec6d37bd1a3ff7b4d5fd60c7c3605831","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"bdb79e3b0432a41bc4f5117424f3d0f8"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
