<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b7a6a27ca65e97b16a8d60abfcc0fb0709bafc2fe8c5c587ba14cde3deaac4800c58e8e30eddff31fe8b693e3fc13aa4bf5b3834835ee33f5a534d37380acde93ef6ae10ab61fba1af900a5067df2c7b3756fb692aca3dc4a9900a536607abef73e812ba009e050891cf257aebe8586adb088ddc4b438e5c20df0dd8a4e44dbf59a49f82ac29ec4252b1575ef8837baf8affc9325f4ce2a50470120ae11d7e2ad9d5b744b796b4bb0f1484323532247135b098902b160214cb14f946aedd2d846eb41b7c3ac279b12fbbef17d3444de94d4959ed92070acccd5ace7be4ac565d8b37b05587ea48ff3625bae70fd9fd987bf7f0ec6c1992a821b70f5faeb817737c1d71e2c183f9854f318c837ab8bfa5ea6958196a2dcf40265a83c4792e5fbe216b8263c5cf844e06ae895607414835bfdf2db20056fe75cc79c4b280ffb8c9d7de15a2503811985be3a9e767dbc9862f9dabf3d7bbab33cbaf9f1c6ea06cbc669e36227b731b45adbd45386ad10a6e4122b425e1f933aa8613aece4390c7a0184825ffd247e285f8feff3d4f10f5a853c26f7ed09e4a1d67f043f79b9c8f2019b0becc6d2743167053fa2b84cc3431c9b2a987a2d1b29151833cd266c51b6c2cff582e2b14c99fe138299d7bc517eedfcdbdaee931eb1e0096cc23fb6b4b16018496983999d2b12e95f894e200b54e2091ec760b3f8896590a844c7f8ecb9537fee495dca93be8daf1f82978a8902b8ca8ad6cc229f7d14248b7caf343abb363ab9312d9586667ddddff35c7b2869ea7cf27522b04fae21396afd429822ec3b7b780e6c47aee0b03405db9c4c0a0c58072d136d04909cea924df40507555de80692376ae804564fb6516b88ffdb9db808cbc7590069cf5a6dddd4a78408bff8f460b087126f624b0a97dd6d309d787ad9d58e3265431876e116b3e2b0ea9628b65f32b0c14631b8a9f0f1d82078fc236e7671e30ec73d33a01b362f6e937f6d45231e78fa7481e4a568a0c4e3414f94751e1e75265bb7c3e12b4efa0edf091905fd256734159bc5f7b714771f88d82aa3291fe62c6af8438b2a281c065566b66e19a16b73388440fdec59961e693f0d2efd04673bcd52a426171c9409d7d96c2092224e7f3b329065e81190a7a2e2ce9447b32fae7a91870788ab609d3ffb1e69e7464486d489d98a8790d04465d26fe45a08d33ad81a6b91b05a471807e38f4caa55e4d529d5a3b668feedf5d91191d55d11f532498eb670b090f200619dc2a6932bd32e06fdd39375eb50eebcd0f3334c9b9edaebbb8908f25ad84755dcd5f5bfb1e7a5c3dc3152e9d2f584c519792e44ab03263b0de104bf0684ea7bfc524982cd64b03d59947bf6ccd011722bef0cd32d3d76503e65aae9877023d6a3ea743b4be39d5b874a90493e1f4c6bf7f92933f92deaa731104944059ecc1ef4c857a7a09afd55021a7cb4a3719dc5dcfc4731bebfdbf5a0d4fb13c23272e8c49abc1923966593184316b1943c8401878d46e6992248f5025e1de8d04e2d7d62c8dba20c5d413382654da044b59ba860a5d48e7065314abf4a76801bf9cb17761f533dc7fcd0f9312b49bb206243725cd02b5f7dd490f12f1866d679183c22aa61ff56fd521d223752b5309f0295748631a862a872f32bc44957318cd36cd391da38023c18f68e7ee6bd5a1316c5aa71a74590bb68756f8dcd8ec94b0ec7a3c74e5c07c270420b18c38c738b1d4a480fd724eadbb6a5eb54829964deb5f77abaf267c500cdaf6d7945b5ecadf17f821ffef708a743724341334a34f1bcfd2f65979596cc40ef8df3e130b1f73f5eb2af251d75850acbceea546df206101b21390af6d3c431df9f80579e6f327a7c914a4b4f43bb0bf8061b15aa734bb5f329a47a3fcfc392244b6e2bc769234a1c420af6ce894d216201de705095fdb8d627dfd4d75c017c240b31069659c2ce98e9ce8bdc55420b842f7cf0ff1f8c6a7715be9477a6241d9cb904bc3a8fed90c19b7a6a4520debc4cafb7e92356c2f8b749ea481e7119ff974bfccc201e30457e1b80f8f3dbc6d6d58ec7a47f5bbfacf1e6e8622caeb8e77facd2f242222440e6e30115382d1b3ed124eca2df18539e621edb88b965ac67c133f07a07ff8c1d51c5853617e58504a7e223d206c17bc0f92ce3ed905076cf348b54755adbed6ebbe5bfc05fc78093be977a262eb503aefdbbfc3363b6658c17136b403772957d65ec7ee659823173d02aee0067ab775fa01586fd7d0bf312a4c54ce9b49b68ec622be0dc681029614b8ef6cc571045193ad164b81dbd6e0fb0cf06b30998b7ad0cc6e6cd1e7723496594959b57509a6cd67451f34b10c2f16876c3fd26a4898fad7be61ac4f2532e87d49639f9e17cff111598727eb4c5f7f3d66275d8ec7cc7d529e73ce91a91231c4f7f51cee56d6b4a46602a9b3b6ddd183f190e2ea5b08844ecd9a0d4201598ecf767e67ae7b346dcb7ef741a2e04991d5114e10efb0dddb3d058023969a2f1a0d139bef46515b2f5d0265fe988b6a1cd2d985a4e40821f1a3365dc908f24628ac9561b6a2e3faf76f92dd610c0ba91b5dbdce427d76cbddcb64fba74fb28eca2a93bdf46823c4239bb02f864a21dc42c90c2b7353a6978968de743b9164524d7a7c6a52f72cf17e2b7bba14bb12c2fc91cce19b47cd6a16190539a78973887fe2d792361e47368b139c30651bf3197e1431378f2dbd497d77e26488a0e09e894442f6b3e5e3f82a01d00f9df170f824e5d49a66e069107fabf07c470f8abb31aeb69c6272957dc3e6db4be26d414dea756a9170efc1ab932794db2522725960c90eac9d3cfac1f7a7f75941cd3a39a94b3620978eb7c11f4c66682f2e3fe3d1b355e11e90d6312142f8526a118d797617460e239debfc93a85560f32d44c256ba0a389db8979917222e451bf8eb15342e6d7bc6520fa6c711f02a3588fec4533f883ed3c20e51bf59633332add4ffa7ab10919e31027826ab7eae58b3c99d08d91d441eb13409c8ff8bc6ed03c94fd5ee223bcc488e1bea11a40e3e1d5880114526816040011cd52c36b5dee7504ca2e6f8569c43693cee1c6e50f7afc815a632c95b69aeac1eb164c8e0c6cd41d6ca9c1cd6dc13a673b7762d30d678a5a098cb1f9e08bc54fd93e7c73230762ce45b8449f8753597110ff6a9cba54077db5e10a8739b9cfc73d9f81d589d63cbad25cb3500dbed9bbb8c433864b289a4fb5215827d12c58eec361ecc0fb0e29c621a398c2a7b4b7423c7babc5055d754f3296b2424d84b3ae6bc87594096a9272a2e6ccd5a08cda0ea320f77d6aeae1a20c00b95042c44b4f331aab5072331960d30c27d9160b70e54cfe10e9789759c65566085024b71d3491ee820492e280a30cb2dfbfb911a332273e728e219d32b5d7f6c9ab957362f693057588cd8ba1a7b2fbbd0364521fcbb644290ec00aa9aa42edfb8cd642168e6d7bb1f27641479ce3e1e7a68561db7c39a2aa3c4b6f0c5a0e9462027ee8c29394c1f01c60cadc8ad396b7e6cfd870e8facf124624cfaa99d416f5ebda459cdf44e5bb08341366f05189c6a92782468f0c603370a5e67fe1566b038d34b060184ea49ac28cba0ba5d51fd3ac3ad898d8c4fea5d2cc6589fd34c33abeb84eb35005bf575319d72a199fbafbe150bfab3e33d76ea85298ec94f415a5e037732cacbc088f6491fdc8c146fbf82c0ad26f38a466cfb170dd4c620500a214c0eb4a38033a2dd855c2335175222032bfe41fc034c5007d9adc4e131c1ec2b0c9cb237166884ac0b4faee2f2b9a3dca88560f71f0ffa3ed5c4e220a896b74dcc2b3fbe8df99d03c2535fdf3e141496da068cbf5c0d18b38768ed6f7ca7fc954bb13d60da6fdb7db5f315ec8bd4c5b273e2c6370db57f1c21df330532a5b9806c4fad3f446b142a02cc8bf55f0f34acf94ac7f7f03209c5935ac307ddec527407d9c79066debee08f48fe80fa1873dcdbaae54a0a91b537630d41b9abe065e89454191c61f1e8cc519409fcbf1f9ebdaeb004eeafa0bf1f492c35bd47a9591be5748d3095650e37d7b730905b39760b4e45c60a324fcba2ef03e7797157a8a0b2dde0871707344d5b975ed93ea8e9c6d1d95bf93ae40e11b567e689cbb63941f5e4fff982e36f17181314d53fc93ab32b36047aca23929e77fff5903846d698018f7c673e8f1e73c89f7a45f207550dedc5e90698373b59bf49da07d7382af090426b12e6af8b817bd5f382e93f9ec323045459c227d0cbf370f001b054b9d470220106966a1372d12c6b3177d02cbf3c3a5cfcc8c91bc6379888e0ef74c63a28eda7abd055952b9f1e7cbd180e27a0b267e5fd4210ad3f23d3cb2f7821a45895bbee942e99e89e212569b919a23cbd2e8cf44ee176313932f469b1d8ac652b179728712cfa1d6f8ecdb00179496973fc9ab5b69200e95e564140cd3e1526bd389495fde3573a3f2a023cbf4e976fee0fbd8e61211851ae03a64d84d38f70afccaa87c37a9a90f20e9ee60860721d25ea10c735f28417ff0431554e8d1a2e00822be120cc3cd194cabe1af2cd591073149444e83e50a5b86c357c779cb7a1d1c8c43b743b8e5f9ad07357e82e53860dc9b2fca1640af45505959105437a6f946015749f7937b3b58f3f963f913efffb8af607ee7182de83cf4571939d64917bd52f1a171ace37856099542d8ace8e1e45379653b3a003df44391acaf5503c1eb76aafbbc71e9f97817b521cae16bdc25cc4c100f95c48471ff2b4ee3b2dae6440f9db8feaa56319165aed43797bdab31cae8fb43d3f34b8cede5e9e84c55eeace4b316bcdc52ad8ccc5d2d9fcd1e72b1f06f752b9e3bc9c035dfde542f11e8b735a7f224d4fdbebfa146337e627a0e77b091dfdeffb8aa6e9b87e978acdc17d31bf5acaa0a5631057fcb0e807658c5c155b938b2819c03e03951dbd352351a9f74453244c074b835bff0ae290550035d2ee6d626b6271f9ea61797af21511e58ab1281edfef4e37294c5f8be0103491bb846dcc16b4c66d52392dd6fc4b7eb562aeff84678ca8337c396b5b5f5fc6c4edfd0b0b7841c1de3ec51b2c7c369bebd4b6f70604dbf673e3a2f39954c12c0eb69e87d118b7399148f74202aa105c29715b558558b873cc4861b3b8356bda426abb6134b3944bab8129e02bc3fa7bdb10b418f232673d82e6ef9395a448b6de47da460857c99359b6dd5b134e5716b0b9eaf5498e8bd31d1c59b2bd0909abca307ffb74512cbde92b0227f3cf4b6559990d51e5e4306052ac9978756ae4237c357a5860c28216ce11b267887e356d65a0eff85551b05338e814b24dc9d65ae053b5b8aedcc043bad992958aab7599e6bbb0f6d3d72d7c6b1fa86f919c0a9db3f3506eef7ebf80a023766800475f34a29162d758cc575b21335c6dc0acbe5b9c30f0830a7b9f8e097d282c07cb362fb47e463501547619663def381f8fadd2d9be56a6f30db11ab42f8e5c926c41d1706194b1b37cb309789792dfd3a9bff033fe4b5b18aac3fec4029271094c01cdb7c2c0a51c04de05161c8bd396df51e0a4c05bcd5ab9f58f18770997d7cc1737e3e7038c56240e5e6fe09213509169bd0c771d7815c257329c4d701f82208da9c364b6dacd6e623589a6b09e487560c39a87ec8b711184e85301a5b4e9e1554fc4b274df52557ea9b29a8a212da98b7dc210b648cfc50c7f09a9d8f763dfcc9f16dc25b756752d1a4544525baa4a74a18cdef4b5ce13999278d7f662f733c4d050617f54e0489b496d72ebe1a3c658f3ae740f22ba151746ecffd49b20af24128b14c1884d6d3755f565bdc1c446091033b929c0641d4fa927dcf64f9e2276ef30bb4b6b01823eb936e848ca7dc7d209718f58c4fcbd2eb8ef46b06e6fe7e85de181cd09ca8a303eacac502482637c30b4ada5ff25d4b6f7a04b6772986c7d117bc1e4d754f3a3b9b4dde3737ec908fd3b204f098c580e35afdc0db23a9ee683c468d1b4af662b57dd73a7579e4bfb88c1f71e54f19260b9f7a1749b81a078c206c0a5ac72684f4553c2bf1afa13d014423affe43daccbc04777074cefb71ec73375edce3154dbe9592edf3e7bc6fb8dbde9453f40b446815096bd7cc5a8f02614c3f517347d8ee50477207dc89c1460deab46ad53f697930739dc46eedac88f983f9e391d080f274c5bfbb05e3824d36a4a409251401a1c78f6df31e1935c4371f013cfc93a556f72bd8fb8f350578afe375b49616752b69d75d5d912a7eb578d72decc142e106eb7eaa1e467dfa2b89a5c848c954339883a65088bb5cb9062bbed3f2b9509fe80636b68587100f5896e6d73ac8a76d200de35fa0273b9ff6bdbea4a38d728ff2a824ef164a43e536e4044b22a97ceb1a027cd2922de547cec10aab005e6c791e6275f15d836d7e3154a3cdddf495dc5d455323704918cf27ba2b8872b99cb3b82ff3a1009abf099ba876adf00927847671cd6eb7c9d9400e88515e1cbcc615711d1a08aaec57f71cdf2372679c16f72e009d60034333b16cd795108bb92fc8a77c33e3b63a48855670c46a1e1e21b75757ff0fb3e6f9fad6f84b1ea1ecc3ad8732affeab623babd0b077094672709e3594b1d4acb2fc7a4a199a3d678f1aa57f61ee9edf6aad6ebb98227589665e56b50a622cf5311375e614f3bcbe8013130794c2ca98d24ddf23a235b3fb17ea42d81f73871ac02e1685a5c584d930b182c208ee8459066561c6468f61ba56e79b32badfa6880f260b40e86a6f93da1803ae62a1d8c40a8098b7ec89c9ce74070717f6e559de580906d63d5fe40288f04f1d169fb3b1b7dd91ec3eb55ece2f6506a2811cd46025bc608fab67ad677f05491edec3942ca00c7415fe4c6d3b2cbcfa79445bcbad25c7a6c5dd841244555c927128741deafdc6c38393386119292493cc7c6d94cd3e12dab194a10d52056189fef4c55001227f37c4190e20966328b027319acb4c9073079d59a87a8dff4601504ee8914a22bcfea476641e95ac8a244f054cea8463f993ad35551ac8b7be007fd33fe2fd00bec61fb9f3ee029975bb81c03f07b87340737a5188ce2c9f749ae41067c79d1e575b9f376b627d12f4d7a92f71466e6525a6cadfbd62459f0058ca8bc431da22b88958dddf613843a8b769b125868a76e1bd5c762091fd43cdb34362956d5fa6d4202a9bd91d9fc88a35432a90852b7b39a619f54532ca1b0c960a878c2b94d6ad3d820081904e7f593fe33f2b0266f5f002765b86f5b7af01e3577d61b436f1d3578a572db5d3c473495bc453b21cad9d26d96cdb1c40a47afce8b0ce384c68563876cabf01f39d91eea15a0d89847bcbf5e579c3c7ac47ae0d3db6f2abcb092de2cc7acc78c01c73bd420d679130ec9157927b0c4fabe3a997214b2b99f08ed68eeb66b2709a396c635e47c812649cd58e8b47b373716569ad1517c90d90ccf2cc1dae12c4008e2e4f4acb8c4c6559e5cfe47b23b34215ad203e46b27c9e4208dfede36ca27f1b65219ec35f5126f14066528414bee8a5c359c20bd090af36e142c30c457d20b74786b0c3c0bb0c2f2fd3baf6e32e66035775f4c938eba3947dfa2ab70238c1b93fa5cecebdb2cb207dbda3804e1a88c70a2c696a22255a9acd61518e9cd737fd189e057efec4f7bedb029bb04889c324d5945e7aa745ddaf8ca625d03c62ab781273be8d5274155112577913312d8ca2f11356c0d4af3b02ed612d0e6a931680f4ddc6b9eb0a65881836cf313ddb8cf2e353a17a5fca0a18487007fa15cd3ec7f3d58f4a15605036bccab14e247763278015195d8276dd182569ab8ea507f3a6d979f4c3fb50b9e7425b8d026d79cef57ff04750146e2a1d3685cd17ddaa3011208cc8b72a264b6d80e16983247df9019814046a56a675cf5f8a2593fb65b5e29483167f314c0acea74f3bd8db6130c1253db9880b909e9a448e211d9094603afa16173f619a3a9026f88e501d7a8dd7fb43d90f186e81e2e364e508d7b9812278deb798189863680df52d9a28a669b13071680d278bc1b0e5ba69e20c1a3d25141dd6ae9098a4990054e1899545579296fd27c05cd0cd445be8cbe7ad1f89f66ea0c50e0a2b5872e1b1a5c725077746f625679f17ebed36294e655e7f5fe3ed8cdf875b72108bd493e92e090f15807ae36be22fdf23c55e19efa963a73122230022c220c1d5029138ce9383da67a9c81839eaa4b049ba605e613fe6c43818d142fc6f9ca454416da1557fc9b3e4457e408edb98b67da91ca1ce6725c188e5758f5701686931bd5d7462258eab3f7aa5fb4aebea99e6f4b7f51a239e13198c3e54b05e41a7504f9b4183257f5a147363ed3b53dfaebc47131c6d1c1c5bcfaabbdc349b9fc447080deae831b363caf5b81c0a2c4c34cf1811fb7590ed5fd592183e02cd76b83e5e06352ac4351350e02b69b8f93002c199ad78a397d89d5ce231e6ec27e85dc4a768be547f942c9328fde0628690432b68615aa86088458c82626af3b556710211ff9d298c694aec297ccd8c8a5b0219cfdfd0434053726c6305752165119e4f9ea430a4e839e8fa38dd19bdfebe9934e06bf4cb36ed52c7a4bad1b76c541ef50895d14498080f137b74ab935409dcfc14b9b99b33d52a225ba565976987f2a139c8def1991f5684f2a935d85102be87828ba018e14ced5783ae986738597f5f8e9e7d069a356813f18889d3668ba415b75edd156d647e6aba4ccb901a32c7ce3429771b0e93dfaa3d08c9a187fe1205f40d4d03fee4926ab462c7186f7082a60f0a3f21a32f4ce2d23b37f15a754c62e6f319b6451d5f36929ebb541f1e635e040b6a471f629bcd44d6bec9fcbd2d8747a976a2caa8e29336865d58c3e7767a50ff4b695a1c60195208bac6652d65cc45e959ef830ea0d5a8d89e11ef3a0103c810fa0f07eff01fb3317660615c072804c9d0f5b49097170d0c1cbb80f95796fc8f11bd5e6ad2a946b94e1b187c752c3cd1b20182dc50df9151a642fb585932bd57f00a021464f95424e7d6d8dccb0c698861da69e7fb55058b69248ba92967b3156d962c08fa62bd0307aeaae58348baa71345b502262791c6cacff69843e70d57427e25b76421400e686e7ae51ad6a4b9c6c8eecd260ffd0e7cd847ff3a21d88cb506a410e92689232e25fa1409b6931af77ac45087ccc3549624bad6180fb96cc15226359b838cb989689d6d7ef8e36bf1d95a08696d221c8145de543537fc410b0df538ed78702dc7c10570842c74f563f866f333347694bd604a16a0f5732a438231354f8b2982be4cd17baed5b007296d69f01fd12d2a0c43f0f36c07e5857fd85ff7acb500fb14b8b8ab00e1b9087c4104441cf4545d4cdb6cf6656615f73b29189c4b0cd3075143fdb922f5a615c62d9e304a9f10133377e103653666fe40f6a4866378c3802527673bb4e7150c00f561831579e48691b19a2e3de67692e3b9f75c84772797595629a936f879b528a2fd6a660d6433116b1291dc1c5c58271c329099d80ae975f7eb5f26fb89509962bf67b8573f47522b06d5d0066f98b3dede40814f408c23bccc620402b0bfc5838d30057884d0ea1fcf437f6bcca139943dff349be98ee0f9ea703ed3eba6df6f804e499f38be23b45ec3c6179342bde1b02f35d39b19bcef8395371557ec9c5e02cdc93ad6c0679a9430f2b1788dd5b995babf0613b5759cb35420525737ca93f6fbd0c9c737876f910d3b87baf72b5990247019c03eda5daf73d4e59f475b9e660e1153bba9e406afbbe6502be1518ddda4eaa44530e740143d88d0732e13cea24924deb97505c6e1f5a9347da9ec13b56a8f8ea01e85a287cd352b4b5286f4871e51f3008c094bcc777477f17a6bf1566071af2e2de83efa194d30464c26f5f86033b61f50d8e7edf285ea1ffddd5751ee17890eaca112010f89db34813d37c9beb3c68f8cd832db03e9835ae9b4c94574bd75e4c80ca5300bb74bdb886f6f7a4a4834f889df357b274705dc7c8099738b04ffbc6094d4d4b3c31e26046a9f152e33c5aca6a85060bff47e0adbbcc745ed7390ddd77042d91def0f9920926c7ef35abea2a4b6f19ce26e48f9759217c099efcbf12401ec90be3503383c1e0c09b94d8cc67805aa742f3673df19d642ea09a753633a81ae85c2a53f523364e16fe628d3741da9694ca6c8828849de03f41920218df069ff86f766d34745933744c5f8e6fe60a941459f440a89da6844254917145e7dbad14d9d9f3a2264bca68f60c38b0cc3ff29cb3f39546d2327687600cedeb4a274271f72e6312ba2ccc99dd35241c91f7deb4ced305464c1859afce979d7d64d737d31cc9939a9ab3d323a8c2a25c257a4703581ce3d8a3ed280a8e62046df717753527cc222af3e3df568ee9425c1189f21d2c91fe770bfeaeaa41d931b3ea39a0b2d69a02c41c2e3adbb9446175b3b5e30ea6448e32135981d0f0f80a13f4bc1d044d94e3052f817cbf5ef2ac3752bbf8f85e1af72e6e040a8c77596af2c92d8af8c1b71c7cfb1509614a85e8e6a0e2bfd6840cec468b83c2d203a8eb519b03f8dda3d5fce905ff76aaf9a75ef589d60fe670a764c851cf653d87a285b8de3bb6896f962adde963c530c92e7f04f192b0cc08d9f03a4363671218acf5dd788a48298a61f317469996229b7e4fbc7a3e5141b440ea5bbb42537d56288b92552b64fedb60816cc7a2bd2987599240d666616b64c48fc6ba1f928f087764c231628e6637a41c987e05a06cd18a14571f31ff8fe744f38b4a2c49b977650b6735bc47142256adc2a74472cea99f8d91262cf43d2a83000add8b3ac6f30378a69588414872154b4ef91f2e3f48dbd85d3fb30405c61fd3f1e340c540b0344196822bac514965e24b406a5c37aca2e9bc5dcf64ff9a4bb96295529cef54ea152b67a06704ef236ab777f477b23cdf25e9ec1c10c011783a3279228c1963750ba9400ba1d5a487f975ce9cb12cb77604523aad303355661c73013fb494a41cbf48ecb7dbd7ffc40bc7482b275ddeb018945a6e6ebfd13cd537c3fcc97f4e0ceb02351232719ca97ac74d70c354b8781d75cae14da62c8c5578b038d741b97bc7ddc0d6203e5ab743646f3d07a0d5414396cf2b703d52c202fea2e78cd11974f583be27736ea808b3dc010b7ec3a5ce33afcc10fa6e2033b8f79cfdf121635beb5c5a4284cec07f69c5ad6c0d1779bbdfa4517fe9702eea8211e6685bf9acb461bcfa58af86653cc4072b171d0a21cff9b9c3790728b8c66e7e988e6c6ecf02b08dfce5439bcb2a761eaeb7b64a3ab869bd1b4e47c62ef23c7eee5b1f025450892edcf23d8b793a0aba38022541f45ccb6a769d5534433c701153495469dd722168d8461bc9e446445b635213163bc326db0f25af6d150b8284a35cc38e2eeedb6f4d359c0cdadea70a63efa2516385b4194046c670573626e9fd27a509e2db279898fe7c397549f20001e099a9ac4cd96e8cf4f855ae75f480b73883ff96b59675018ab04a7c63ce47b28cc9efc9e95b66165af9cb445e32c4976e4ae9066ff2700434bce020159c30630486953fa9882ad9d0c4060ab7a0eae72770ca1bcd479a28a59284125ed239cab86fbb7e060936e19480971cceebf53d7e61e1793fcc2aa2fe40e05f880bb1e73e5666fb96e78730071214ffecfa69462c3184ca2321a39835e0bbaadeeb2be34900c836d71bdfb0f5dce361312acdadcdab5cdb5ba0ae54ab5cebff617e99ee652a00726b7e180b5e6ef139f0bb913eb259d05e4a1c2eda854358efaedae69fe013a9e8852183f6b382b3841cffb841277df7fddc907add968cb88c46a087355e7ce36f2a0dc221bbd0f65b3ba756ffc8020919a80751144d4ed238400073f3176a6c1ed480437a53a9c8146d9edba318962bb896619829fe12ce3c10aa9681f3874cf9502651655b0edb3f6e369de92bc34621b77eeefb8c2e51622bfe6c725d1fde1ae3ca3bfe1563c58069eaca5419e26f2c9b00ce4f74969cf05cbac149e67e5f38a0990d9bf3f31739f405df44e2e43b8b1ae9fad940c9ef203f7d2d4f83199f1c1b652333e8867128a66d6eef30180f8685fcd0ff68c5f75a4e46986aac599d6c480f86d52b4dbad6a83ab2364f40838e1614132dc74a811109355d8675793c92f4d13a02b5bfe228aac9ebfb5870e7fe7241c0bb2d363cd16c8475015e12787edf423b46eb95dada1a72fe521f1d333b819656a433ef3656aafe6c7d11334218b9aa459deb525675530bfdc06f73824543dd31c800c457d582235fb0665c35f959fc250f5ec577651a4d2ec7535dc976997a1b7b9292867cbc8084087a953d82f066c80986d7fd5e299dd2b463b2271cc4aceac776d6fead17efb261347f5a3dd1e2af450cf19691e1704a716f428f0501e4ade25e2a87a9967843ebbc4e032d0022ce49d00d26936ce4661cd0d2fd3156bba97f9ceb47303f16eb03a17e81d6909b9a5185e65999c5fd43749fe1df6da7cc4ec6df23dbf8e2056b285e70e02855bac07fb1285b74412a664b592ee234d7b4218668d270f2616e184baeb0ecef97cb0c46cd745ea252aa67b7556fc29b9baf7f8efbffa918ab96c980de7c212146b1d718d0a83a048c959e17bb75d42bb00b22e2e64df600ae1619e2b315f17ae2af2d70e70ad98a79e93ca2e6551aa7f35b486f72cdf64b053b6cb3796175c9db8aa7797eec02c27b205707742525f22808f95b93b6c440187963fe38834fa3001af719a91416e10ee31e579fa9917d1e8f3722e7e1a20546ae0ddcd77fd1bd705d082976e954fa233c838a7eee81838e6122145ab3eda04d1fa0978381e4ca894fdb8aeceb70448a70e8f822fb7729e65c21d41b8d4b191cb9db4b691e11e0981f43af093aac5cb9cba53b62edfa2a7b00d77cdcde92df4280b471f2ba3be952fcc778dc2dbff9dea95721e8336cc4d49347843afef2137f4a15cb1335f146afc9543e3c7c86791f98e68929b91e2f002451003f78a0666ee8c9ea642a473d54acb44126ae871bc871c6bd72c5db3d319035e50a3a42498d1b2876f350c29df67fa891469043a3f431eab06de8123e01a80a8b367dc9d0f79e8fce1bdd1d09d799c73bcef441822441761bf4acef341978256ebe9771172f324dc861b5e0d02162768b21011899a4d5a54819798ecc975f0f5cd5991f2cb4668becae10f72e3924c2a2f210c0ef6f4ddfa33dd8d033c0b9c18c402161d7dfef3d39342c617c22904e5b3d39534586f2c14f5c4428c33a3f570affe50134cf9c1538999a7b97e653410b581a5d95d40dbad5a39cb26b1ba777fbeed7287a656fece19c936402bdad7a77b511f3e66c5318994ed0603d5ef3b77a78e7c586248d8545afa5951284c90dbd3489c62e5d41e534e99e5f3c6695872e05bf31578f990b8d9907cfd0f7c3f073a9b427a40cc79838bde22aaea62b639990cf3e651071c0b02fe228922e19d2daa3995b96baec4f639ba06ff33f39de2e0bd02988690877fe0dabd732d6ffa9148ebfa288d8ef47b3e97877d16b266d0b28010f6853a14a3b3716f093ada74aa820dd4a7752e812753bc6cc5730b1f00e1c5a536786cadea79cf0c270eef535442addf6a47ed1b75ce949257ecdbebbe851fdf6a82619f834a6a54a1e7143e6f04260ca4616b15ad2597e4b0d1a647653a92473e0febbfbd2df56ea7277530df69a45c2d97cefa97934bd53096da6717598bceb7e4a305694652ee3c3392f76c7205e2f9604a8603b8f911d9f433067db3746beb0cea471847fb7b69dfa1e8fb4c719e4b0afab76742980d8489d1bcba548c72535e9a46342dd0046a3d3eadd0a4cd01ce2d40749dec73b0852a1a06cc62e4027349514c464e7f1ffc600808aae00f96eb3194708b652daff3524af1605e3b05146d749379f879f3ea5f731a0cd312571dd5f7b4a1dcef48513c6c733dcbf292b438957271451f392b138245546c816b48107218f444d55bd81e6f58a12a3719d2f3b603304ec39f6b0f3d774c05b5c29db45e335691f73d70880d6265be1b99f42660a3113f8370f4bb06db741466b8eec5451781ccd2e27afa9562ed8e08aca36832ce23f43c90efd54fb9d45e65fadd503eb10e19e0e8d5c0b50899c8bea26f91fa0468bf53f8971793e41762b7820f64d5ae5617bd36d8b78bdf00b2e4a2d8924e7c436dd47402ccec5af89a41e8f6b3e607f27c2cf494de5e10a8e6a133b102bd56f4d0cb4dd42b77a7e643b940af4888010676f90d0dbd99b9c0bdf2a90ef8c7e6a38d8113d1b9089402c93ee90891b58d7753ae7bea148f717d69b5026b00ede6e91ea7b4cf08ed5e61fd8d75753246427906c030b53bee6ff8c19c3cd1a35aaee90357028ad68d9cedf0bafc0b738bc99e98537ed01cdc76e7a05e1721663ab8131f7d2963c0c9975af7ee659b1e1aa3c86e15295468bfc293da29fb1e8a62ab0ac0591927e1a01193e53dbb67639b0a28ea09da229a88e25f376a369a36955cbb1457dff104709df159358c55557a15ac9b87d6efa20cf67618f0c237b5c0abe4ccbbc652ce77e0732f7994e2779cfb5533ec5f2b334874ba3e5cb53e62df30e9a3b7c0ac11becbcd058d477108d75b9e37638dacb0da92d533ba433e64585ca526f9dc5ccc9af4c349ab241ff18161b647e55f5df696248e4787401394eac8651a9b5bc50a574d76328337cc7be623cb2b37e7882e2e8c1ae075ccb8220139543e52e0354a5713c41dd3d2d2caeeb16cf118af3ca8ad9e23790a54b1fcbd35c10f45019885ed3b2a961614b58c2a4fc5f7c6a32ac411e9e0d58dfb8e32b1f21c31f218ac56dac5e3f10ebaeae12bf4f711b65dbf76d99a7cd8382b562646afe85b4e37302a77f89f0684b1ce3da8d86db17cce258928c7bc58e24826b2fd12a30822a13d25ea7f53418e1e1769cb6cd5fe2fdbd553b792d626c71d3a6c2f148b3591e47a391add999917b3e8f36bbfd54e42a4fa1a11494ab1dddb73037cfb2aedd5966bf863de00f038614416d1e866bfb3dac61f7759c37dd114c230b9ed2bbf541f5ee8ec987e7f35466b46187e68d3c2b899a325ee3353d647fc6f40e040c445152e31643ca21f396a02565fb3c9d49e92e775e430c256988e275d56969e9d21904077f7f3faccc9795424720523cf701997d4bbe871003c8c79afe44e1f985d4a9d33542ad247beada3159a1cc0954d08c81bf4fdfff8df95c37af85a88b0e133fefb27ee3954ac62616d22da013af1c50edf64d99f04492e1f89d3ed2950e0adca44dfe3bf9a55fc24b6e9a6f9c685732cd94f5aeaf52fe1ab1495f937028fdef49a0594c0960b57631aae8a6b212d94f6c12abd229273d33036ecec4573c1f0ddfba97841df580e6f81bc1aa0f15f414c9d0481833c2a80dc979349b6c15828eb24fd1bc649b6eebaaa750a04200fcf330eaed1f6d202dab63637a92d4824fe0d64fb2f5b7e8e08fb7afe2bd5aef4d50f41069a15ba7118eb03db28d23312fe7ed0c3271f95920617270eff5a4141fcb18fed66e30ce784c43fd91c962f0e0d4949643ece1b2e2e28b2b08d7c3e6320b6dad9ce913b6080e8d6e660bbaeb29c2901d87c38db376727b4c8c018823167e23ed8464f19de57aae06789868d69ce3e128ce3e47c5c3aa0f3f90aed133e2e60b3b8a59199596a031f99c7c334e4bc8921e8ff5879f7858256194aee3a9e28fe6e79da95c58633dd00ad23fa2774d2115ade91367e787d14587ce04a75c088191ae5353e1ff0e546a249627b3c1835217a627c6cc22625dae9d43e65ccbccf3e6035f1946b8d2e3dd67a6514a27179aa7b5ed1d789cbd87257120e7047de5cbcf83fd54e2e7d97e80f85200a49c78b72bf986e703b5841c295966dcc097fb6d1bfada9b13157c599c981fced84edbb628edec506986056dfeb490d51187b131bb6085453ddecb7ce44fef2114ba1d6fd79e3f20658fb034f6c5513eed65eb27606559a87203de00370c3d66ee6670aea219637beb8564f47d14a8d31ba588e7d2a0f6e0e68421a20cdf644c2fdbe7ecc62ec26265913276a55a1e06cca5028fdb29718b457794c1e85f0edb86a72c6623fa54e119c456fe4a8513494df1b9b735d077b7044d1170a285afb232ae2555a7a114d260e3c99446440da932b93de3a274c862b475a79514de578bfe3adbd88d085044da26520ed5d0e408fa83531f8201669a85210deed9f63f3c6310697407649c5f9ea5c69119b70a28ef32fcced7be74f8e99b5e92e7cb2de4a4d3c3e31d19e3d26544583359860de0b3260a9c20b2884cdaf7a9e80c4586cb58a1f97539cb1b7433f279d9883b00dbd04d4dd90f219ffc47c5349a941fa539f523fe7409cbfe611da0001772e9dc6ad2f546042a0e4a8cec8510a32b5c9da04489d9bf2ae1bcdd766e4db0d2d598ea65b60295373422821e9b8ad7d4739ffe9786de46f27c41ed36be4e98c02923eafaf3f1c7745291ea2bde235b588ce05b7188aeffa1eed43c927b20bc52e406620ed33b6f770f5449f5c03b686be74af53f88289def45bd136aee67d338b99f391df9209888fe3317a6c554a9d0f66cec2ece8a51ac5eacc77b758b745c2aae7aa5d61ec8368d97d3a00aee1771ba07cfa2c0c93ab01c4d6c71dc877130ff87cc3fbba0506ed5bf3923186817eb4c77dfaa2e98398f7a4596525b48399591bbd9b1da00f4a0635a9e5d9ce60cc9d89dc1d54462d8f46b481b14e5a977f2ee8678d3f9099421aca29b5dd27a7f35ac0f933a09c7b11e57cbeddf29a681cdc613eeb1b155d47e32fa7471dd8f513a186a21971eeb5aa8a8904c8bc802c01e6744f5892662afb99d92481b6e14998e63a66bb1e175aaa357dd122242227b82bb4e6294e6b7fc718f3c20a90e4ab13491602de36ed631e5f819a072d3c968a11606f4d00d634eeeb070b87a67b0817742c66cb1f761125c1b11efd0b77676cc1b6ef70c8c10f6c7db41e4d3e77ee9bd0875094b4e544add04d94d5650cc6cf2a536a888dde0d88399f684fa878e0541338df282ef8b4afccc831be8fbd5d2724ce2c233d6a9ae163762b4e1e0a12fbb1159260d4b93a3d2d23e26194c7fc85da813","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"bdb79e3b0432a41bc4f5117424f3d0f8"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
